<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mapr | Tug's Blog]]></title>
  <link href="http://tgrall.github.io/blog/categories/mapr/atom.xml" rel="self"/>
  <link href="http://tgrall.github.io/"/>
  <updated>2020-01-02T17:56:59+01:00</updated>
  <id>http://tgrall.github.io/</id>
  <author>
    <name><![CDATA[Tug Grall]]></name>
    <email><![CDATA[tugdual@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Getting Started With MapR-DB Table Replication]]></title>
    <link href="http://tgrall.github.io/blog/2017/08/08/getting-started-with-mapr-db-table-replication/"/>
    <updated>2017-08-08T10:01:19+02:00</updated>
    <id>http://tgrall.github.io/blog/2017/08/08/getting-started-with-mapr-db-table-replication</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>MapR-DB Table Replication allows data to be replicated to another table that could be on on the same cluster or in another cluster. This is different from the automatic and intra-cluster replication that copies the data into different physical nodes for high availability and prevent data loss.</p>

<p>This tutorial focuses on the MapR-DB Table Replication that replicates data between tables on different clusters.</p>

<p>Replicating data between different clusters allows you to:</p>

<ul>
<li>provide another level of disaster recovery that protects your data and applications against global data center failure,</li>
<li>push data close to the applications and users,</li>
<li>aggregate the data from mutliple datacenters.</li>
</ul>


<p><strong>Replication Topologies</strong></p>

<p>MapR-DB Table Replication provides various topologies to adapt the replication to the business and technical requirements:</p>

<ul>
<li><em>Master-slave replication</em> : in this topology, you replicate one way from source tables to replicas. The replicas can be in a remote cluster or in the cluster where the source tables are located.</li>
<li><em>Multi-Master replication</em> : in this replication topology, there are two master-slave relationships, with each table playing both the role of a master and a slave. Client applications update both tables and each table replicates updates to the other.</li>
</ul>


<p>In this example you will learn how to setup multi-master replication.</p>

<!-- more -->


<h3>Prerequisites</h3>

<ul>
<li>2 MapR Clusters 5.x with Enterprise Edition license

<ul>
<li>in this demonstration they are called <code>cluster1</code> and <code>cluster2</code></li>
</ul>
</li>
</ul>


<h2>Setting Up Replication</h2>

<p>In the next steps you will configure your clusters to enable mutip-master replication as follow:</p>

<p><img src="http://tgrall.github.io/images/posts/maprdb-replication/replication.png" alt="Architecture" /></p>

<h3>Configuring the clusters</h3>

<p>Each node of the source cluster must communicate with the destination cluster&rsquo;s CLDB nodes. On each node of your source cluster edit the <code>mapr-clusters.conf</code> file and add the destination cluster information.</p>

<p><em>Cluster 1 Configuration</em></p>

<p>In all the nodes of <code>cluster1</code>, edit the  <code>/opt/mapr/conf/mapr-clusters.conf</code> file and add the <code>cluster2</code> configuration. The file should look like the following:</p>

<pre><code>cluster1 secure=false cluster1-node1:7222 cluster1-node2:7222 cluster1-node2:7222

cluster2 secure=false cluster2-node1:7222 cluster2-node2:7222 cluster2-node3:7222
</code></pre>

<p><em>Cluster 2 Configuration</em></p>

<p>In all the nodes of <code>cluster2</code>, edit the  <code>/opt/mapr/conf/mapr-clusters.conf</code> file and add the <code>cluster1</code> configuration. The file should look like the following:</p>

<pre><code>cluster2 secure=false cluster2-node1:7222 cluster2-node2:7222 cluster2-node3:7222

cluster1 secure=false cluster1-node1:7222 cluster1-node2:7222 cluster1-node2:7222
</code></pre>

<p>You can find information about the <code>mapr-clusters.conf</code> format in <a href="http://maprdocs.mapr.com/home/ReferenceGuide/mapr-clusters.conf.html">the documentation</a>.</p>

<p>Open a terminal window on one of the <code>cluster1</code> node using <code>mapr</code> user, and do the following:</p>

<pre><code>$ ls /mapr/cluster1/
apps   hbase  installer  opt  tmp  user  var

$ ls /mapr/cluster2/
apps   hbase  installer  opt  tmp  user  var
</code></pre>

<h3>Installing and Configuring the MapR Gateway</h3>

<p>A MapR gateway mediates one-way communication between a source MapR cluster and a destination MapR cluster. In this example you will use mult-master replication, this means that data will be replicated from <code>cluster1</code> to <code>cluster2</code> and from <code>cluster2</code> to <code>cluster1</code>.</p>

<p>The good practice is to install the MapR-Gateway to the destination cluster, so in our case let&rsquo;s install one gateway on one of the <code>cluster1</code> node, and one gateway on one of the <code>cluster2</code> node. Note that this configuration will not be highly available, and usually you will deploy more than 1 gateway by cluster.</p>

<h4>Installing the MapR-Gateway</h4>

<p>As root on one node of the <code>cluster1</code>, adapt the command to your linux environment, for example on the node <code>cluster1-node2</code></p>

<pre><code>$ yum install mapr-gateway


# Update MapR configuration
$ /opt/mapr/server/configure.sh -N cluster1 -C cluster1-node1:7222,cluster1-node2:7222,cluster1-node3:7222 -R
</code></pre>

<p>Do the same on <code>cluster2</code>, for example on the node <code>cluster2-node2</code>:</p>

<pre><code>$ yum install mapr-gateway


# Update MapR configuration
$ /opt/mapr/server/configure.sh -N cluster1 -C cluster2-node1:7222,cluster2-node2:7222,cluster2-node3:7222 -R
</code></pre>

<h4>Registering the Gateway to the Clusters</h4>

<p>Now that we have a gateway running on each cluster, you have to <strong><em>register the gateway</em></strong> in each cluster.</p>

<p>On <code>cluster1</code> run the following command to register the <code>cluster2</code> gateway as destination:</p>

<pre><code>$ maprcli cluster gateway set -dstcluster cluster2 -gateways cluster2-node2

# Check the configuration
$ maprcli cluster gateway list
</code></pre>

<p>On <code>cluster2</code> run the following command to register the <code>cluster1</code> gateway as destination:</p>

<pre><code>$ maprcli cluster gateway set -dstcluster cluster1 -gateways cluster1-node2

# Check the configuration
$ maprcli cluster gateway list
</code></pre>

<h3>Creating Table with Replication</h3>

<p>In a terminal window, as <code>mapr</code> user on <code>cluster1</code>, create a table and insert documents:</p>

<pre><code>$ maprcli table create -path /apps/user_profiles  -tabletype json
</code></pre>

<p>This create a new JSON table; it is also possible to use <code>/mapr/cluster1/apps/user_profiles</code>.</p>

<p>Let&rsquo;s now add documents using MapR-DB Shell:</p>

<pre><code>$ mapr dbshell

maprdb mapr:&gt; insert /apps/user_profiles --value '{"_id":"user001" , "first_name":"John", "last_name":"Doe"}'

maprdb mapr:&gt; find /apps/user_profiles
</code></pre>

<h4>Adding Table Replication</h4>

<p>Let&rsquo;s now enable replication between <code>user_profiles</code> on <code>cluster1</code> to a <code>user_profiles</code> table in <code>cluster2</code>.</p>

<p>In <code>cluster1</code>, on a terminal window as <code>mapr</code> run the following command:</p>

<pre><code>$ maprcli table replica autosetup -path /apps/user_profiles -replica /mapr/cluster2/apps/user_profiles -multimaster yes
</code></pre>

<p>You can get information about the replication configuration for the table using the following command:</p>

<pre><code>$ maprcli table replica list -path /apps/user_profiles -json
</code></pre>

<h4>Testing Replication</h4>

<p>Open another terminal in <code>cluster2</code> and use MapR-DB Shell to look at the replicated data:</p>

<pre><code>$ mapr dbshell

maprdb mapr:&gt; find /apps/user_profiles
{"_id":"user001","first_name":"John","last_name":"Doe"}
1 document(s) found.
</code></pre>

<p>You can also use the full path <code>/mapr/cluster2/apps/user_profiles</code></p>

<p>In <code>cluster1</code> add a new document using MapR-DB Shell:</p>

<pre><code>$ mapr dbshell

maprdb mapr:&gt; insert /apps/user_profiles --value '{"_id":"user002" , "first_name":"Simon", "last_name":"Dupont"}'

maprdb mapr:&gt; find /apps/user_profiles
</code></pre>

<p>Do a find in <code>cluster2</code> table, and you will see that the data have been replicated.</p>

<p>You can insert or delete a document in <code>cluster2</code> and do a find in <code>cluster1</code>, you will see that the new document is also replicated in the other direction.</p>

<p>Note, for this demonstration, we use 2 terminals connected to each cluster you can do some test using the Global Namespace in a single MapR-DB Shell.</p>

<h2>Conclusion</h2>

<p>In this tutorial you have learned how to setup the MapR-DB Multi-Master replication to have data automatically replicated between 2 clusters.</p>

<p>MapR-DB Table Replication provides many options, not only in term of topology (master-slave/mult-master), but also some options and commands to:</p>

<ul>
<li>replicate some columns/attributes or column family</li>
<li>configure replication in a secured cluster</li>
<li>pause replication.</li>
</ul>


<p>You can find more information about the MapR-DB Table Replication, and MapR-Gateway in the documentation:</p>

<ul>
<li><a href="http://maprdocs.mapr.com/home/MapR-DB/ReplicatingMapR-DBTables.html">Table Replication</a></li>
<li><a href="http://maprdocs.mapr.com/home/MapR-DB/ConfiguringMapRClustersForTR.html">Setting up Table Replication</a></li>
<li><a href="http://maprdocs.mapr.com/home/Gateways/MapRGateways.html">Configuring and Managing MapR Gateways</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started With Kafka REST Proxy for MapR Streams]]></title>
    <link href="http://tgrall.github.io/blog/2017/01/20/getting-started-with-kafka-rest-proxy-for-mapr-streams/"/>
    <updated>2017-01-20T10:31:22+01:00</updated>
    <id>http://tgrall.github.io/blog/2017/01/20/getting-started-with-kafka-rest-proxy-for-mapr-streams</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>MapR Ecosystem Package 2.0 (MEP) is coming with some new features related to MapR Streams:</p>

<ul>
<li><a href="http://maprdocs.mapr.com/home/Kafka/kafkaREST.html">Kafka REST Proxy for MapR Streams</a> provides a RESTful interface to MapR Streams and Kafka clusters to consume and product messages and to perform administrative operations.</li>
<li><a href="http://maprdocs.mapr.com/home/Kafka/kafkaConnect.html">Kafka Connect for MapR Streams</a> is a utility for streaming data between MapR Streams and Apache Kafka and other storage systems.</li>
</ul>


<p>MapR Ecosystem Packs (MEPs) are a way to deliver ecosystem upgrades decoupled from core upgrades - allowing you to upgrade your tooling independently of your Converged Data Platform. You can lean more about MEP 2.0 in <a href="https://www.mapr.com/blog/announcing-mapr-ecosystem-pack-mep-20">this article</a>.</p>

<p>In this blog we describe how to use the REST Proxy to publish and consume messages to/from MapR Streams. The REST Proxy is a great addition to the MapR Converged Data Platform allowing any programming language to use MapR Streams.</p>

<p>The Kafka REST Proxy provided with the MapR Streams tools, can be used with MapR Streams (default), but also used in a hybrid mode with Apache Kafka. In this article we will focus on MapR Streams.</p>

<!-- more -->


<h2>Prerequisites</h2>

<ul>
<li>MapR Converged Data Platform 5.2 with MEP 2.0

<ul>
<li>with MapR Streams Tools</li>
</ul>
</li>
<li>curl, wget or any HTTP/REST Client tool</li>
</ul>


<h2>Create the MapR Streams and Topic</h2>

<p>A stream is a collection of topics that you can manage as a group by:</p>

<ol>
<li>Setting security policies that apply to all topics in that stream</li>
<li>Setting a default number of partitions for each new topic that is created in the stream</li>
<li>Set a time-to-live for messages in every topic in the stream</li>
</ol>


<p>You can find more information about MapR Streams concepts in the <a href="http://maprdocs.mapr.com/home/MapR_Streams/mapr_streams.html">documentation</a>.</p>

<p>On your Mapr Cluster or Sandbox, run the following commands:</p>

<pre><code>$ maprcli stream create -path /apps/iot-stream -produceperm p -consumeperm p -topicperm p

$ maprcli stream topic create -path /apps/iot-stream -topic sensor-json -partitions 3

$ maprcli stream topic create -path /apps/iot-stream -topic sensor-binary -partitions 3
</code></pre>

<h2>Start Kafka Console Producers and Consumers</h2>

<p>Open two terminal windows and run the consumer Kafka utilities using the following commands:</p>

<h4>Consumer</h4>

<ul>
<li>Topic sensor-json</li>
</ul>


<pre><code>$ /opt/mapr/kafka/kafka-0.9.0/bin/kafka-console-consumer.sh --new-consumer --bootstrap-server this.will.be.ignored:9092 --topic /apps/iot-stream:sensor-json
</code></pre>

<ul>
<li>Topic sensor-binary</li>
</ul>


<pre><code>$ /opt/mapr/kafka/kafka-0.9.0/bin/kafka-console-consumer.sh --new-consumer --bootstrap-server this.will.be.ignored:9092 --topic /apps/iot-stream:sensor-binary
</code></pre>

<p>This two terminal windows will allow you to see the messages posted on the different topics</p>

<h2>Using Kafka REST Proxy</h2>

<h3>Inspect Topic Metadata</h3>

<p>The endpoint <code>/topics/[topic_name]</code> allows you to get some informations about the topic. In MapR Streams, topics are part of a <em>stream</em> identified by a path;
to use the topic using the REST API you have to use the full path, and encode it in the URL; for example:</p>

<ul>
<li><code>/apps/iot-stream:sensor-json</code> will be encoded with <code>%2Fapps%2Fiot-stream%3Asensor-json</code></li>
</ul>


<p>Run the following command, to get information about the <code>sensor-json</code> topic</p>

<pre><code>$ curl -X GET  http://localhost:8082/topics/%2Fapps%2Fiot-stream%3Asensor-json
</code></pre>

<p>Note: For simplicity reason I am running the command from the node where the Kafka REST proxy is running, so it is possible to use <code>localhost</code>.</p>

<p>You can print JSON in a pretty way, by adding a Python command such as :</p>

<pre><code>$ curl -X GET  http://localhost:8082/topics/%2Fapps%2Fiot-stream%3Asensor-json | python -m json.tool
</code></pre>

<p><strong>Default Stream</strong></p>

<p>As mentioned above, the Stream path is part of the topic name you have to use in the command;
however it is possible to configure the MapR Kafka REST Proxy to use a default stream.
For this you should add the following property in the <code>/opt/mapr/kafka-rest/kafka-rest-2.0.1/config/kafka-rest.properties</code> file:</p>

<ul>
<li><code>streams.default.stream=/apps/iot-stream</code></li>
</ul>


<p> When you change the Kafka REST proxy configuration, you must restart the service using maprcli or MCS.</p>

<p> The main reason to use the <code>streams.default.stream</code> properties is to simplify the URLs used by the application for example
 * with <code>streams.default.stream</code> you can use <code>curl -X GET  http://localhost:8082/topics/</code>
 * without this configuration, or if you want to use a specific stream you must specify it in the URL <code>http://localhost:8082/topics/%2Fapps%2Fiot-stream%3Asensor-json</code></p>

<p> In this article, all the URLs contains the encoded stream name, like that you can start using the Kafka REST proxy without changind the configuration and also use it with different streams.</p>

<h3>Publishing Messages</h3>

<p>The Kafka REST Proxy for MapR Streams allows application to publish messages to MapR Streams. Messages could be send as JSON or Binary content (base64 encoding).</p>

<h4>To send a JSON Message:</h4>

<ul>
<li>the query should be a HTTP <code>POST</code></li>
<li>the Content-Type should be : <code>application/vnd.kafka.json.v1+json</code></li>
<li>the Body:</li>
</ul>


<pre><code class="JSON">{
  "records":
  [
    {
      "value":
      {
        "temp" : 10 ,
        "speed" : 40 ,
        "direction" : "NW"
        }  
      }
  ]
}
</code></pre>

<p>The complete request is:</p>

<pre><code>curl -X POST -H "Content-Type: application/vnd.kafka.json.v1+json" \
  --data '{"records":[{"value": {"temp" : 10 , "speed" : 40 , "direction" : "NW"}  }]}' \
  http://localhost:8082/topics/%2Fapps%2Fiot-stream%3Asensor-json
</code></pre>

<p>You should see the message printed in the terminal window where the <code>/apps/iot-stream:sensor-json</code> consumer is running.</p>

<h4>To send a binary Message:</h4>

<ul>
<li>the query should be a HTTP <code>POST</code></li>
<li>the Content-Type should be : <code>application/vnd.kafka.binary.v1+json</code></li>
<li>the Body:</li>
</ul>


<pre><code class="JSON">{
  "records":
  [
    {
      "value":"SGVsbG8gV29ybGQ="
    }
  ]
}
</code></pre>

<p>Note that <code>SGVsbG8gV29ybGQ=</code> is the string &ldquo;Hello World&rdquo; encoded in Base64.</p>

<p>The complete request is:</p>

<pre><code>curl -X POST -H "Content-Type: application/vnd.kafka.binary.v1+json" \
  --data '{"records":[{"value":"SGVsbG8gV29ybGQ="}]}' \
  http://localhost:8082/topics/%2Fapps%2Fiot-stream%3Asensor-binary
</code></pre>

<p>You should see the message printed in the terminal window where the <code>/apps/iot-stream:sensor-binary</code> consumer is running.</p>

<h4>Sending multiple messages</h4>

<p>The <code>records</code> field of the HTTP Body allows you to send multiple messages for example you can send:</p>

<pre><code>curl -X POST -H "Content-Type: application/vnd.kafka.json.v1+json" \
  --data '{"records":[{"value": {"temp" : 12 , "speed" : 42 , "direction" : "NW"}  }, {"value": {"temp" : 10 , "speed" : 37 , "direction" : "N"}  } ]}' \
  http://localhost:8082/topics/%2Fapps%2Fiot-stream%3Asensor-json
</code></pre>

<p>This command will send 2 messages, and increment the offset by 2. You can do the same
with binary content, just add new element in the JSON array; for example:</p>

<pre><code>curl -X POST -H "Content-Type: application/vnd.kafka.binary.v1+json" \
  --data '{"records":[{"value":"SGVsbG8gV29ybGQ="}, {"value":"Qm9uam91cg=="}]}' \
  http://localhost:8082/topics/%2Fapps%2Fiot-stream%3Asensor-binary
</code></pre>

<p>As you probably know, it is possible to set a key to a message to be sure that all the messages
with the same key will arrive in the same partition. For this, add the <code>key</code> attribute to the message as follow:</p>

<pre><code class="JSON">{
  "records":
  [
    {
      "key": "K001",
      "value":
      {
        "temp" : 10 ,
        "speed" : 40 ,
        "direction" : "NW"
        }  
      }
  ]
}
</code></pre>

<p>Now that you know how to post messages to MapR Stream topics usinf the REST Proxy, let&rsquo;s see how to consume the messages.</p>

<h3>Consuming Messages</h3>

<p>The REST proxy can also be used to consume messages from topics; for this you need to:</p>

<ol>
<li>Create a consumer instance.</li>
<li>Use this URL returned by the first call to read message.</li>
<li>Delete the consumer instanced if needed.</li>
</ol>


<h4>Creating the consumer instance</h4>

<p>The following request creates the consumer instance:</p>

<pre><code>curl -X POST -H "Content-Type: application/vnd.kafka.v1+json" \
      --data '{"name": "iot_json_consumer", "format": "json", "auto.offset.reset": "earliest"}' \
      http://localhost:8082/consumers/%2Fapps%2Fiot-stream%3Asensor-json
</code></pre>

<p>The response from the server looks like:</p>

<pre><code class="json">{
  "instance_id":"iot_json_consumer",
  "base_uri":"http://localhost:8082/consumers/%2Fapps%2Fiot-stream%3Asensor-json/instances/iot_json_consumer"
}
</code></pre>

<p>Note that we have used the <code>/consumers/[topic_name]</code> to create the consumer.</p>

<p>The <code>base_uri</code> will be used by the subsequent requests to get the messages from the topic. Like any MapR Streams/Kafka consumer the <code>auto.offset.reset</code> defines its behavior. In this example the value is set to <code>earliest</code>, this means that the consumer will read the messages from the beginning. You can find more information about the consumer configuration in the <a href="http://maprdocs.mapr.com/home/MapR_Streams/configuration_parameters_for_consumers.html">MapR Streams documentation</a>.</p>

<h4>Consuming the messages</h4>

<p>To consume the messages, just add the Mapr Streams topic to the URL of the consumer isntance.</p>

<p>The following request consumes the messages from the topic:</p>

<pre><code>curl -X GET -H "Accept: application/vnd.kafka.json.v1+json" \
http://localhost:8082/consumers/%2Fapps%2Fiot-stream%3Asensor-json/instances/iot_json_consumer/topics/%2Fapps%2Fiot-stream%3Asensor-json
</code></pre>

<p>This call returns the messages in a JSON document:</p>

<pre><code class="json">[
  {"key":null,"value":{"temp":10,"speed":40,"direction":"NW"},"topic":"/apps/iot-stream:sensor-json","partition":1,"offset":1},
  {"key":null,"value":{"temp":12,"speed":42,"direction":"NW"},"topic":"/apps/iot-stream:sensor-json","partition":1,"offset":2},
  {"key":null,"value":{"temp":10,"speed":37,"direction":"N"},"topic":"/apps/iot-stream:sensor-json","partition":1,"offset":3}
]
</code></pre>

<p>Each call to the API returns the new messages published, based on the offset of the last call.</p>

<p>Note that the Consumer will be destroyed:</p>

<ul>
<li>after some idle time set by the <code>consumer.instance.timeout.ms</code> (default value set to 300000ms / 5 minutes)</li>
<li>where it is destroyed using a REST API call (see below).</li>
</ul>


<h3>Consuming binary format messages</h3>

<p>The approach is the same if you need to consume binary messages, you need to change the format and accept header.</p>

<p>Call this URL to create a consumer instance for the binary topic:</p>

<pre><code>curl -X POST -H "Content-Type: application/vnd.kafka.v1+json" \
      --data '{"name": "iot_binary_consumer", "format": "binary", "auto.offset.reset": "earliest"}' \
      http://localhost:8082/consumers/%2Fapps%2Fiot-stream%3Asensor-binary
</code></pre>

<p>Then consume messages, the accept header is set to <code>application/vnd.kafka.binary.v1+json</code>:</p>

<pre><code>curl -X GET -H "Accept: application/vnd.kafka.binary.v1+json" \
http://localhost:8082/consumers/%2Fapps%2Fiot-stream%3Asensor-binary/instances/iot_binary_consumer/topics/%2Fapps%2Fiot-stream%3Asensor-binary
</code></pre>

<p>This call returns the messages in a JSON document, and the value is encoded in Base64</p>

<pre><code class="json">[
  {"key":null,"value":"SGVsbG8gV29ybGQ=","topic":"/apps/iot-stream:sensor-binary","partition":1,"offset":1},
  {"key":null,"value":"Qm9uam91cg==","topic":"/apps/iot-stream:sensor-binary","partition":1,"offset":2}
]
</code></pre>

<h3>Delete consumer instances</h3>

<p>As mentioned before the consumer will be destroyed automatically based on the <code>consumer.instance.timeout.ms</code> configuration of the REST Proxy;
it is also possible to destroyed the instance using the consumer instance URI and an HTTP DELETE call, as follow:</p>

<pre><code>curl -X DELETE http://localhost:8082/consumers/%2Fapps%2Fiot-stream%3Asensor-binary/instances/iot_binary_consumer
</code></pre>

<h2>Conclusion</h2>

<p>In this article you have learned how to use the Kafka REST Proxy for MapR Streams that allow any application to
use messages published in the MapR Converged Data Platform.</p>

<p>You can find more information about the Kafka REST Proxy in the <a href="http://maprdocs.mapr.com/home/Kafka/REST-proxy.html">MapR documentation</a> and the following resources:</p>

<ul>
<li><a href="https://www.mapr.com/blog/getting-started-sample-programs-mapr-streams">Getting Started with MapR Streams</a></li>
<li><a href="https://www.mapr.com/streaming-architecture-using-apache-kafka-mapr-streams">&ldquo;Streaming Architecture: New Designs Using Apache Kafka and MapR Streams&rdquo; ebook by Ted Dunning and Ellen Friedman</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started With Apache Flink and Mapr Streams]]></title>
    <link href="http://tgrall.github.io/blog/2016/10/17/getting-started-with-apache-flink-and-mapr-streams/"/>
    <updated>2016-10-17T10:12:10+02:00</updated>
    <id>http://tgrall.github.io/blog/2016/10/17/getting-started-with-apache-flink-and-mapr-streams</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p><a href="https://flink.apache.org/">Apache Flink</a> is an open source platform for distributed stream and batch data processing. Flink is a streaming data flow engine with several APIs to create data streams oriented application.</p>

<p>It is very common for Flink applications to use <a href="http://kafka.apache.org/">Apache Kafka</a> for data input and output.</p>

<p>This article will guide you into  the steps to use Apache Flink with <a href="https://www.mapr.com/products/mapr-streams">MapR Streams</a>. MapR Streams is a distributed messaging system for streaming event data at scale, and it’s integrated into the <a href="https://www.mapr.com/products/mapr-converged-data-platform">MapR Converged Data Platform</a>, based on the Apache Kafka API (0.9.0),
this article use the same code and approach than the <a href="http://tgrall.github.io/blog/2016/10/12/getting-started-with-apache-flink-and-kafka/">Flink and Kafka Getting Started</a>.</p>

<p><img src="http://tgrall.github.io/images/posts/flink-kafka/flink-mapr-streams.png" alt="MapR Streams and Flink" />.</p>

<!-- more -->


<h3>Prerequisites</h3>

<ul>
<li>MapR 5.2

<ul>
<li>You can use <a href="https://www.mapr.com/products/mapr-sandbox-hadoop">MapR Converged Data Platform Sandbox</a></li>
</ul>
</li>
<li>MapR Client installed on your development host

<ul>
<li><a href="http://maprdocs.mapr.com/home/AdvancedInstallation/SettingUptheClient-install-mapr-client.html">Installation and Configuration steps</a></li>
</ul>
</li>
<li>Git</li>
<li>Maven 3.x or later</li>
</ul>


<h2>Create your Flink Streaming Project</h2>

<p>The first step is to create an Java application, the easiest is to use the flink-quickstart-java archetype, that contains the core dependencies and packaging tasks. This article is similar with the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.1/quickstart/run_example_quickstart.html">Apache Flink Quick Start Example</a>, with a clear focus on data input and output with MapR Streams.</p>

<p>In this application we will create two jobs:</p>

<ul>
<li><code>WriteToKafka</code> : that generates random string and post them to a MapR Streams Topic using the Kafka Flink Connector and its Producer API.</li>
<li><code>ReadFromKafka</code> : that reads the same topic and print the messages in the standard output using the Kafka Flink Connector and its Consumer. API.</li>
</ul>


<p>The full project is available on GitHub:</p>

<ul>
<li><a href="https://github.com/mapr-demos/mapr-streams-flink-demo">MapR Streams Flink Demo</a></li>
</ul>


<p>Let’s create the project using Apache Maven:</p>

<pre><code>mvn archetype:generate \
      -DarchetypeGroupId=org.apache.flink\
      -DarchetypeArtifactId=flink-quickstart-java \
      -DarchetypeVersion=1.1.2 \
      -DgroupId=com.mapr.demos \
      -DartifactId=mapr-streams-flink-demo \
      -Dversion=1.0-SNAPSHOT \
      -DinteractiveMode=false 
</code></pre>

<p>Maven will create the following structure:</p>

<pre><code>$ tree mapr-streams-flink-demo/
mapr-streams-flink-demo/
├── pom.xml
└── src
    └── main
        ├── java
        │   └── com
        │       └── mapr
        │           └── demos
        │               ├── BatchJob.java
        │               ├── SocketTextStreamWordCount.java
        │               ├── StreamingJob.java
        │               └── WordCount.java
        └── resources
            └── log4j.properties
</code></pre>

<p>This project is configured to create a Jar file that contains your flink project code and also includes all dependencies needed to run it.</p>

<p>The project contains some other sample jobs, we do not need them for this article, you can either keep them to educational purposes or simply remove them from the project.</p>

<h2>Add Kafka &amp; MapR Streams Dependencies</h2>

<p>Open the <code>pom.xml</code> and add the following dependencies to your project:</p>

<p><strong>1- Add MapR Maven Repository</strong></p>

<p>In the <code>&lt;repositories&gt;</code> element add :</p>

<pre><code>   &lt;repository&gt;
     &lt;id&gt;mapr-releases&lt;/id&gt;
     &lt;url&gt;http://repository.mapr.com/maven/&lt;/url&gt;
     &lt;snapshots&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/snapshots&gt;
     &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;
   &lt;/repository&gt;
</code></pre>

<p><strong>2- Add MapR Streams libraries</strong></p>

<p>In the <code>&lt;dependencies&gt;</code> element:</p>

<pre><code> &lt;dependency&gt;
   &lt;groupId&gt;com.mapr.streams&lt;/groupId&gt;
   &lt;artifactId&gt;mapr-streams&lt;/artifactId&gt;
   &lt;version&gt;5.2.0-mapr&lt;/version&gt;
 &lt;/dependency&gt;
 &lt;dependency&gt;
   &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
   &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;
   &lt;version&gt;0.9.0.0-mapr-1602&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre>

<p><strong>3- Add Flink Kafka Connector libraries</strong></p>

<p>As a first step, we have to add the Flink Kafka connector as a dependency so that we can use the Kafka sink. Add this to the pom.xml file in the dependencies section:</p>

<p>You must add now the Flink Kafka Connector dependency to use the Kafka sink. Add the following entry in the <code>&lt;dependencies&gt;</code> element:</p>

<pre><code> &lt;dependency&gt;
      &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;
      &lt;artifactId&gt;flink-connector-kafka-0.9_2.10&lt;/artifactId&gt;
      &lt;version&gt;${flink.version}&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre>

<p><strong>4- Exclude Kafka Client to allow use of MapR Streams Client</strong></p>

<p>As you may know, MapR Streams uses the Kafka 0.9.0 API to produce and consume messages. So we need now to remove (exclude) tha Apache Kafka Client API to be sure that Flink use MapR Streams.</p>

<p>In the Flink Kafka Connector dependency add the following exclusion:</p>

<pre><code>  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;
    &lt;artifactId&gt;flink-connector-kafka-0.9_2.10&lt;/artifactId&gt;
    &lt;version&gt;${flink.version}&lt;/version&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
          &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;
        &lt;/exclusion&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
          &lt;artifactId&gt;kafka_2.10&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
  &lt;/dependency&gt;
</code></pre>

<p>The Flink project is now ready to use the DataStream using the Kafka Connector so you can send and receive messages from MapR Streams.</p>

<p>Let’s now create a Stream in MapR and write some simple Flink code to use it.</p>

<h2>Create the MapR Streams and Topic</h2>

<p>A stream is a collection of topics that you can manage as a group by:</p>

<ol>
<li>Setting security policies that apply to all topics in that stream</li>
<li>Setting a default number of partitions for each new topic that is created in the stream</li>
<li>Set a time-to-live for messages in every topic in the stream</li>
</ol>


<p>You can find more information about MapR Streams concepts in the <a href="http://maprdocs.mapr.com/51/MapR_Streams/concepts.html">documentation</a>.</p>

<p>On your Mapr Cluster or Sandbox run the following commands:</p>

<pre><code>$ maprcli stream create -path /apps/application-stream -produceperm p -consumeperm p -topicperm p
$ maprcli stream topic create -path /apps/application-stream -topic flink-demo 
</code></pre>

<h3>Install and use MapR Kafka utilities</h3>

<p>Install <code>the mapr-kafka</code> package on your cluster :</p>

<pre><code>yum install mapr-kafka
</code></pre>

<p>Open two terminal windows and run the producer and consumer kafka utilities using the following commands:</p>

<p>Producer</p>

<pre><code>/opt/mapr/kafka/kafka-0.9.0/bin/kafka-console-producer.sh --broker-list this.will.be.ignored:9092 --topic /apps/application-stream:flink-demo
</code></pre>

<p>Consumer</p>

<pre><code>/opt/mapr/kafka/kafka-0.9.0/bin/kafka-console-consumer.sh --new-consumer --bootstrap-server this.will.be.ignored:9092 --topic /apps/application-stream:flink-demo
</code></pre>

<p>In the producer window, you can post some messages and see them in the consumer windows. We will use these tools to follow the interactions between MapR Streams and Flink.</p>

<h2>Write your Flink application</h2>

<p>Let’s now use the Flink Kafka Connector to send messages to MapR Streams and consume them.</p>

<h3>Producer</h3>

<p>The producer generates messages using the <code>SimpleStringGenerator()</code> class and send the string to the <code>/apps/application-stream:flink-demo</code> topic.</p>

<pre><code>  public static void main(String[] args) throws Exception {
    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

    Properties properties = new Properties();
    // properties.setProperty("bootstrap.servers", "&lt;kafka-broker&gt;:9092"); // not used by MapR Streams
    properties.setProperty("streams.buffer.max.time.ms", "200");

    DataStream&lt;String&gt; stream = env.addSource(new SimpleStringGenerator());
    stream.addSink(new FlinkKafkaProducer09&lt;&gt;("/apps/application-stream:flink-demo", new SimpleStringSchema(), properties));

    env.execute();
  }
</code></pre>

<p>The <code>SimpleStringGenerator()</code> method code is available <a href="https://github.com/mapr-demos/mapr-streams-flink-demo/blob/master/src/main/java/com/mapr/demos/WriteToKafka.java#L46-L61">here</a>.</p>

<p>The main steps are:</p>

<ul>
<li>create a new <code>StreamExecutionEnvironment</code> the basis of any Flink application</li>
<li>create a new <code>DataStream</code> in the application environment, the <code>SimpleStringGenerator</code> class implements the <code>[SourceFunction](https://ci.apache.org/projects/flink/flink-docs-release-1.1/api/java/)</code> the base interface for all streams data sources in Flink.</li>
<li>add the <code>FlinkKafkaProducer09</code> sink to the streams; since MapR Streams is based on Kafka API 0.9, it is possible to use the FlinkKafkaProducer09 class; with 2 small differences:

<ul>
<li>the broker list (first parameter) is not used since MapR Streams use the cluster location defined in the <code>/opt/mapr/conf/mapr-clusters.conf</code> class.</li>
<li>the topic name include the path and name of the MapR Stream stream in which the topic is located for example <code>/apps/application-stream:flink-demo</code></li>
</ul>
</li>
</ul>


<h3>Consumer</h3>

<p>The consumer simply reads the messages from the <code>/apps/application-stream:flink-demo</code> topic, and print them into the console.</p>

<pre><code>  public static void main(String[] args) throws Exception {
    // create execution environment
    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

    Properties properties = new Properties();
    // properties.setProperty("bootstrap.servers", "&lt;kafka-broker&gt;:9092"); // not used by MapR Streams
    properties.setProperty("group.id", "flink_consumer");

    DataStream&lt;String&gt; stream = env.addSource(new FlinkKafkaConsumer09&lt;&gt;(
        "/apps/application-stream:flink-demo", new SimpleStringSchema(), properties) );

    stream.map(new MapFunction&lt;String, String&gt;() {
      private static final long serialVersionUID = -6867736771747690202L;

      @Override
      public String map(String value) throws Exception {
        return "Stream Value: " + value;
      }
    }).print();

    env.execute();
  }
</code></pre>

<p>The main steps are:</p>

<ul>
<li>create a new <code>StreamExecutionEnvironment</code> the basis of any Flink application</li>
<li>create a set of properties with the consumer information, in this application we can only set the consumer <code>group.id</code>. Note that the <code>bootstrap.servers</code> property is not used by MapR Streams, so no need to set it.</li>
<li>use the <code>FlinkKafkaConsumer09</code> to get the message from the MapR Streams topic <code>/apps/application-stream:flink-demo</code></li>
</ul>


<h2>Build and Run the application</h2>

<p>Let’s run the application directly from Maven (or from your favorite IDE).</p>

<p>1- Build the project:</p>

<pre><code>$ mvn clean package
</code></pre>

<p>2- Run the Flink Producer Job</p>

<pre><code>$ mvn exec:java -Dexec.mainClass=com.mapr.demos.WriteToKafka
</code></pre>

<p>3- Run the Flink Consumer Job</p>

<pre><code>$ mvn exec:java -Dexec.mainClass=com.mapr.demos.ReadFromKafka
</code></pre>

<p>In the terminal, you should see the messages generated from the producer</p>

<p>You can now deploy and execute this job on your Flink cluster.</p>

<h2>Conclusion</h2>

<p>In this article you have learned how to use Flink with MapR Streams to write and read data streams. The key element is the configuration of the Maven Dependencies to configure the project to use MapR Streams libraries instead of Kafka ones.</p>

<p>This was originally published on the <a href="https://www.mapr.com/blog/getting-started-apache-flink-and-mapr-streams">MapR blog here</a>.</p>

<p>Learn about what Apache Flink can do and how it maintains consistency and provides flexibility in the &ldquo;<a href="https://www.mapr.com/introduction-to-apache-flink">Introduction to Apache Flink</a>&rdquo; ebook.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting Up Spark Dynamic Allocation on MapR]]></title>
    <link href="http://tgrall.github.io/blog/2016/09/01/setting-up-spark-dynamic-allocation-on-mapr/"/>
    <updated>2016-09-01T11:15:57+02:00</updated>
    <id>http://tgrall.github.io/blog/2016/09/01/setting-up-spark-dynamic-allocation-on-mapr</id>
    <content type="html"><![CDATA[<p>Apache Spark can use various cluster manager to execute application (Stand Alone, YARN, Apache Mesos). When you install Apache Spark on MapR you can submit application in a Stand Alone mode or using YARN.</p>

<p>This article focuses on YARN and Dynamic Allocation, a feature that lets Spark add or remove executors dynamically based on the workload. You can find more information about this feature in this presentation from Databricks:</p>

<ul>
<li><a href="http://www.slideshare.net/databricks/dynamic-allocation-in-spark">Dynamic Allocation in Spark</a></li>
</ul>


<p>Let’s see how to configure Spark and YARN to use dynamic allocation (that is disabled by default).</p>

<!-- more -->


<h4>Prerequisites</h4>

<ul>
<li>MapR Converged Data Platform Cluster</li>
<li>Apache Spark for MapR installed</li>
</ul>


<p>This example has been described for MapR 5.2 with Apache Spark 1.6.1, you just need to adapt the version to your environment.</p>

<h3>Enabling Dynamic Allocation in Apache Spark</h3>

<p>The first thing to do is to enable Dynamic Allocation in Spark, for this you need to edit the spark configuration file on each Spark node.</p>

<pre><code>/opt/mapr/spark/spark-1.6.1/conf/spark-defaults.conf
</code></pre>

<p>and add the following entries:</p>

<pre><code>spark.dynamicAllocation.enabled = true
spark.shuffle.service.enabled = true
spark.dynamicAllocation.minExecutors = 5 
spark.executor.instances = 0
</code></pre>

<p>You can find additional configuration options in the <a href="http://spark.apache.org/docs/1.6.1/configuration.html#dynamic-allocation">Apache Spark Documentation</a>.</p>

<h3>Enabling Spark External Shuffle for YARN</h3>

<p>You have now to edit YARN configuration to add information about Spark Shuffle Service, edit the following file, on each YARN node:</p>

<pre><code>/opt/mapr/hadoop/hadoop-2.7.0/etc/hadoop/yarn-site.xml
</code></pre>

<p>add these properties:</p>

<pre><code>  &lt;property&gt;
    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;
    &lt;value&gt;mapreduce_shuffle,mapr_direct_shuffle,spark_shuffle&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;yarn.nodemanager.aux-services.spark_shuffle.class&lt;/name&gt;
    &lt;value&gt;org.apache.spark.network.yarn.YarnShuffleService&lt;/value&gt;
  &lt;/property&gt;
</code></pre>

<h4>Add Spark Shuffle to YARN classpath</h4>

<p>Spark Shuffle service must be added to the YARN classpath. The jar is located in the spark distribution:</p>

<pre><code>/opt/mapr/spark/spark-1.6.1/lib/spark-1.6.1-mapr-1605-yarn-shuffle.jar
</code></pre>

<p>To achieve this add the jar in the following folder on each node:</p>

<pre><code>/opt/mapr/hadoop/hadoop-2.7.0/share/hadoop/yarn/lib
</code></pre>

<p>You can either copyy the file or create a symlink:</p>

<pre><code>$ ln -s /opt/mapr/spark/spark-1.6.1/lib/spark-1.6.1-mapr-1605-yarn-shuffle.jar /opt/mapr/hadoop/hadoop-2.7.0/share/hadoop/yarn/lib
</code></pre>

<h4>Restart YARN</h4>

<p>Since you have changed the YARN configuration <em>you must restart your node managers</em> using the following command:</p>

<pre><code>$ maprcli node services -name nodemanager -action restart -nodes [list of nodes]
</code></pre>

<h3>Submitting a Spark Job</h3>

<p>Your MapR Cluster is not ready to use Spark dynamic allocation, this means that when you submit a job you do not need to specify any resource configuration, for example:</p>

<pre><code>/opt/mapr/spark/spark-1.6.1/bin/spark-submit \
  --class com.mapr.demo.WordCountSorted \
  --master yarn \
  ~/spark-examples-1.0-SNAPSHOT.jar \
  /mapr/my.cluster.com/input/4gb_txt_file.txt \
  /mapr/my.cluster.com/user/mapr/output/
</code></pre>

<p>note that you can still specify the resources, but in this case the dynamic allocation will not be used for this specific job, for example:</p>

<pre><code>/opt/mapr/spark/spark-1.6.1/bin/spark-submit \
  --class com.mapr.demo.WordCountSorted \
  --master yarn \
  --num-executors 3
  --executor-memory 1G \
  ~/spark-examples-1.0-SNAPSHOT.jar \
  /mapr/my.cluster.com/input/4gb_txt_file.txt \
  /mapr/my.cluster.com/user/mapr/output/
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Save MapR Streams Messages Into MapR DB JSON]]></title>
    <link href="http://tgrall.github.io/blog/2016/03/31/save-mapr-streams-messages-into-mapr-db-json/"/>
    <updated>2016-03-31T09:00:07+02:00</updated>
    <id>http://tgrall.github.io/blog/2016/03/31/save-mapr-streams-messages-into-mapr-db-json</id>
    <content type="html"><![CDATA[<p>In this article you will learn how to create a MapR Streams Consumer that saves all the messages into a <a href="http://maprdocs.mapr.com/51/#MapR-DB/JSON_DB/mapr_db_json_top.html">MapR-DB JSON Table</a>.</p>

<!-- more -->


<h3>Install and Run the sample MapR Streams application</h3>

<p>The steps to install and run the applications are the same as the one defined in the following article:</p>

<ul>
<li><a href="https://www.mapr.com/blog/getting-started-sample-programs-mapr-streams">MapR Streams application</a></li>
</ul>


<p>Once you have the default producer and consumer running in your environment using the commands:</p>

<p>Producer:</p>

<pre><code>$ java -cp $(mapr classpath):./mapr-streams-examples-1.0-SNAPSHOT-jar-with-dependencies.jar com.mapr.examples.Run producer
</code></pre>

<p>Consumer:</p>

<pre><code>$ java -cp $(mapr classpath):./mapr-streams-examples-1.0-SNAPSHOT-jar-with-dependencies.jar com.mapr.examples.Run consumer
</code></pre>

<h3>Save messages into MapR-DB JSON</h3>

<p>The <a href="https://github.com/mapr-demos/mapr-streams-sample-programs/blob/master/src/main/java/com/mapr/examples/DBConsumer.java">DBConsumer</a> class is a copy of the <a href="https://github.com/mapr-demos/mapr-streams-sample-programs/blob/master/src/main/java/com/mapr/examples/Consumer.java">Consumer</a> class with small changes to save the messages coming from the <code>/sample-stream:fast-messages</code> topic into a MapR-DB table named <code>/apps/fast-messages</code>.</p>

<p><strong>1- Add MapR-DB Maven dependency to your project</strong></p>

<p>Edit the <code>pom.xml</code> file and add the following entry in the <code>dependencies</code> tag:</p>

<pre><code class="xml">   &lt;dependency&gt;
      &lt;groupId&gt;com.mapr.db&lt;/groupId&gt;
      &lt;artifactId&gt;maprdb&lt;/artifactId&gt;
      &lt;version&gt;5.1.0-mapr&lt;/version&gt;
   &lt;/dependency&gt;
</code></pre>

<p>This add support for:</p>

<ul>
<li><a href="http://ojai.io/">OJAI</a> Open JSON Application Interface</li>
<li><a href="http://maprdocs.mapr.com/51/#MapR-DB/JSON_DB/crud_with_maprdb_ojai_java_api.html">MapR-DB JSON API</a></li>
</ul>


<p><strong>2- Create and Get a JSON Table</strong></p>

<p>To save the messages, the application must access a JSON Table, for this just call the <code>MapRDB.getTable(TABLE_PATH)</code> method. If the table does not exist, create it with the <code>MapRDB.createTable(TABLE_PATH)</code>.</p>

<p>This is what the <a href="https://github.com/mapr-demos/mapr-streams-sample-programs/blob/master/src/main/java/com/mapr/examples/DBConsumer.java#L113-L119"><code>DBConsumer.getTable(TABLE_PATH)</code></a> method is doing.</p>

<pre><code class="java">  private static Table getTable(String tablePath) {
    if ( ! MapRDB.tableExists(tablePath)) {
      return MapRDB.createTable(tablePath);
    } else {
      return MapRDB.getTable(tablePath);
    }
  }
</code></pre>

<p>When the DBConsumer starts the <a href="https://github.com/mapr-demos/mapr-streams-sample-programs/blob/master/src/main/java/com/mapr/examples/DBConsumer.java#L41"><code>getTable("/apps/fast-messages")</code></a> method is called.</p>

<pre><code>  Table fastMessagesTable = getTable("/apps/fast-messages");
</code></pre>

<p>The table <code>fastMessagesTable</code> is not available to the consumer.</p>

<p><strong>3- Save messages into the JSON Table</strong></p>

<p>Messages can be saved into the table using the <a href="https://github.com/mapr-demos/mapr-streams-sample-programs/blob/master/src/main/java/com/mapr/examples/DBConsumer.java#L78-L81">MapR-DB JSON Java API</a>.</p>

<p>The producer sends the message as JSON String that is converted into a JSON object names <code>msg</code>. This object can be used to create an OJAI Document:</p>

<pre><code>  Document messageDocument = MapRDB.newDocument(msg);
</code></pre>

<p>To be saved into MapR-DB, a document must have a <code>_id</code> field. In this example let’s use the message number generated by the producer <em>(JSON field <code>k</code>)</em>.</p>

<pre><code>  messageDocument.setId( Integer.toString(messageDocument.getInt("k")));
</code></pre>

<p>Let’s now save the document into the table:</p>

<pre><code>  fastMessagesTable.insertOrReplace( messageDocument );       
</code></pre>

<p>Each time the producer will be executed, the message number counter will be initialized to 0. So the document _id will be the same, and the document into the table must be replaced; this is why the <code>insertOrReplace</code> method is used.</p>

<p>Let’s run the new consumer.</p>

<p><strong>4- Run the DBConsumer</strong></p>

<p>To run the DBConsumer just pass the parameter <code>dbconsumer</code> as follow:</p>

<p>Consumer:</p>

<pre><code>$ java -cp $(mapr classpath):./mapr-streams-examples-1.0-SNAPSHOT-jar-with-dependencies.jar com.mapr.examples.Run dbconsumer
</code></pre>

<p>Note that a new <a href="https://github.com/mapr-demos/mapr-streams-sample-programs/blob/master/src/main/java/com/mapr/examples/DBConsumer.java#L48-L54">group is created</a> to be sure that messages are read by the two different consumers (Consumer and DBConsumer).</p>

<p><strong>5- Query the messages saved into MapR-DB</strong></p>

<p>Messages are saved into the <code>/apps/fast-messages</code> table, let’s used the MapR DBShell to query the data. On your cluster run the following commands, as <code>mapr</code>:</p>

<pre><code>$ mapr dbshell
maprdb mapr:&gt; find /apps/fast-messages --id 100
{"_id":"100","type":"test","t":64986.787,"k":{"$numberLong":100}}
</code></pre>

<h3>Conclusion</h3>

<p>In this very simple example, the DBConsumer takes each message and saved it as a simple JSON Document into MapR-DB JSON. The table can be used to create any type of application, or using Apache Drill <em>(1.6 or later)</em> to do some analytics.</p>

<p>In a real application the messages will probably be modified, enriched and/or aggregated and then the result be saved into MapR-DB Table. The goal of this sample is just to show that it is easy to integrate MapR Streams and MapR-DB.</p>

<p>You have also other alternative to achieve the same thing using for example:</p>

<ul>
<li>Spark Streaming</li>
<li>3rd Party ETL and Tools</li>
</ul>

]]></content>
  </entry>
  
</feed>

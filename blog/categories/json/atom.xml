<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Json | Tug's Blog]]></title>
  <link href="http://tgrall.github.io/blog/categories/json/atom.xml" rel="self"/>
  <link href="http://tgrall.github.io/"/>
  <updated>2020-05-16T18:24:59+02:00</updated>
  <id>http://tgrall.github.io/</id>
  <author>
    <name><![CDATA[Tug Grall]]></name>
    <email><![CDATA[tugdual@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Save MapR Streams Messages Into MapR DB JSON]]></title>
    <link href="http://tgrall.github.io/blog/2016/03/31/save-mapr-streams-messages-into-mapr-db-json/"/>
    <updated>2016-03-31T09:00:07+02:00</updated>
    <id>http://tgrall.github.io/blog/2016/03/31/save-mapr-streams-messages-into-mapr-db-json</id>
    <content type="html"><![CDATA[<p>In this article you will learn how to create a MapR Streams Consumer that saves all the messages into a <a href="http://maprdocs.mapr.com/51/#MapR-DB/JSON_DB/mapr_db_json_top.html">MapR-DB JSON Table</a>.</p>

<!-- more -->


<h3>Install and Run the sample MapR Streams application</h3>

<p>The steps to install and run the applications are the same as the one defined in the following article:</p>

<ul>
<li><a href="https://www.mapr.com/blog/getting-started-sample-programs-mapr-streams">MapR Streams application</a></li>
</ul>


<p>Once you have the default producer and consumer running in your environment using the commands:</p>

<p>Producer:</p>

<pre><code>$ java -cp $(mapr classpath):./mapr-streams-examples-1.0-SNAPSHOT-jar-with-dependencies.jar com.mapr.examples.Run producer
</code></pre>

<p>Consumer:</p>

<pre><code>$ java -cp $(mapr classpath):./mapr-streams-examples-1.0-SNAPSHOT-jar-with-dependencies.jar com.mapr.examples.Run consumer
</code></pre>

<h3>Save messages into MapR-DB JSON</h3>

<p>The <a href="https://github.com/mapr-demos/mapr-streams-sample-programs/blob/master/src/main/java/com/mapr/examples/DBConsumer.java">DBConsumer</a> class is a copy of the <a href="https://github.com/mapr-demos/mapr-streams-sample-programs/blob/master/src/main/java/com/mapr/examples/Consumer.java">Consumer</a> class with small changes to save the messages coming from the <code>/sample-stream:fast-messages</code> topic into a MapR-DB table named <code>/apps/fast-messages</code>.</p>

<p><strong>1- Add MapR-DB Maven dependency to your project</strong></p>

<p>Edit the <code>pom.xml</code> file and add the following entry in the <code>dependencies</code> tag:</p>

<pre><code class="xml">   &lt;dependency&gt;
      &lt;groupId&gt;com.mapr.db&lt;/groupId&gt;
      &lt;artifactId&gt;maprdb&lt;/artifactId&gt;
      &lt;version&gt;5.1.0-mapr&lt;/version&gt;
   &lt;/dependency&gt;
</code></pre>

<p>This add support for:</p>

<ul>
<li><a href="http://ojai.io/">OJAI</a> Open JSON Application Interface</li>
<li><a href="http://maprdocs.mapr.com/51/#MapR-DB/JSON_DB/crud_with_maprdb_ojai_java_api.html">MapR-DB JSON API</a></li>
</ul>


<p><strong>2- Create and Get a JSON Table</strong></p>

<p>To save the messages, the application must access a JSON Table, for this just call the <code>MapRDB.getTable(TABLE_PATH)</code> method. If the table does not exist, create it with the <code>MapRDB.createTable(TABLE_PATH)</code>.</p>

<p>This is what the <a href="https://github.com/mapr-demos/mapr-streams-sample-programs/blob/master/src/main/java/com/mapr/examples/DBConsumer.java#L113-L119"><code>DBConsumer.getTable(TABLE_PATH)</code></a> method is doing.</p>

<pre><code class="java">  private static Table getTable(String tablePath) {
    if ( ! MapRDB.tableExists(tablePath)) {
      return MapRDB.createTable(tablePath);
    } else {
      return MapRDB.getTable(tablePath);
    }
  }
</code></pre>

<p>When the DBConsumer starts the <a href="https://github.com/mapr-demos/mapr-streams-sample-programs/blob/master/src/main/java/com/mapr/examples/DBConsumer.java#L41"><code>getTable("/apps/fast-messages")</code></a> method is called.</p>

<pre><code>  Table fastMessagesTable = getTable("/apps/fast-messages");
</code></pre>

<p>The table <code>fastMessagesTable</code> is not available to the consumer.</p>

<p><strong>3- Save messages into the JSON Table</strong></p>

<p>Messages can be saved into the table using the <a href="https://github.com/mapr-demos/mapr-streams-sample-programs/blob/master/src/main/java/com/mapr/examples/DBConsumer.java#L78-L81">MapR-DB JSON Java API</a>.</p>

<p>The producer sends the message as JSON String that is converted into a JSON object names <code>msg</code>. This object can be used to create an OJAI Document:</p>

<pre><code>  Document messageDocument = MapRDB.newDocument(msg);
</code></pre>

<p>To be saved into MapR-DB, a document must have a <code>_id</code> field. In this example let’s use the message number generated by the producer <em>(JSON field <code>k</code>)</em>.</p>

<pre><code>  messageDocument.setId( Integer.toString(messageDocument.getInt("k")));
</code></pre>

<p>Let’s now save the document into the table:</p>

<pre><code>  fastMessagesTable.insertOrReplace( messageDocument );       
</code></pre>

<p>Each time the producer will be executed, the message number counter will be initialized to 0. So the document _id will be the same, and the document into the table must be replaced; this is why the <code>insertOrReplace</code> method is used.</p>

<p>Let’s run the new consumer.</p>

<p><strong>4- Run the DBConsumer</strong></p>

<p>To run the DBConsumer just pass the parameter <code>dbconsumer</code> as follow:</p>

<p>Consumer:</p>

<pre><code>$ java -cp $(mapr classpath):./mapr-streams-examples-1.0-SNAPSHOT-jar-with-dependencies.jar com.mapr.examples.Run dbconsumer
</code></pre>

<p>Note that a new <a href="https://github.com/mapr-demos/mapr-streams-sample-programs/blob/master/src/main/java/com/mapr/examples/DBConsumer.java#L48-L54">group is created</a> to be sure that messages are read by the two different consumers (Consumer and DBConsumer).</p>

<p><strong>5- Query the messages saved into MapR-DB</strong></p>

<p>Messages are saved into the <code>/apps/fast-messages</code> table, let’s used the MapR DBShell to query the data. On your cluster run the following commands, as <code>mapr</code>:</p>

<pre><code>$ mapr dbshell
maprdb mapr:&gt; find /apps/fast-messages --id 100
{"_id":"100","type":"test","t":64986.787,"k":{"$numberLong":100}}
</code></pre>

<h3>Conclusion</h3>

<p>In this very simple example, the DBConsumer takes each message and saved it as a simple JSON Document into MapR-DB JSON. The table can be used to create any type of application, or using Apache Drill <em>(1.6 or later)</em> to do some analytics.</p>

<p>In a real application the messages will probably be modified, enriched and/or aggregated and then the result be saved into MapR-DB Table. The goal of this sample is just to show that it is easy to integrate MapR Streams and MapR-DB.</p>

<p>You have also other alternative to achieve the same thing using for example:</p>

<ul>
<li>Spark Streaming</li>
<li>3rd Party ETL and Tools</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MongoDB : Playing With Arrays]]></title>
    <link href="http://tgrall.github.io/blog/2015/04/21/mongodb-playing-with-arrays/"/>
    <updated>2015-04-21T15:45:39+02:00</updated>
    <id>http://tgrall.github.io/blog/2015/04/21/mongodb-playing-with-arrays</id>
    <content type="html"><![CDATA[<p>As you know,  you have many differences between relational and document databases. The biggest, for the developer, is probably the data model: Row versus Document. This is particularly true when we talk about &ldquo;relations&rdquo; versus &ldquo;embedded documents <em>(or values)</em>&rdquo;. Let&rsquo;s look at some examples, then see what are the various operations provided by MongoDB to help you to deal with this.</p>

<!-- more -->


<p>I won&rsquo;t use this post to go in all the details about &ldquo;document design&rdquo;, but I just want to focus on the operations you can to with these arrays/list (so useful operations once you have chosen to embed documents).</p>

<p>Let&rsquo;s use a very simple example based on e-commerce platform, with two document types : <strong><em>user</em></strong> and <strong><em>orders</em></strong>.</p>

<p>The first thing you have, is a simple list of values into a JSON array. Let&rsquo;s look at a user profile where user have a list of interests  (field <code>interested_by</code>) :</p>

<pre><code class="json">{
  "_id" : 654321,
  "first_name" : "John",
  "last_name" : "Doe",
  "interested_by" : [ "electronics", "sports", "music" ],
  "address" : {
    "name" : "John Doe",
    "company" : "Resultri",
    "street" : "1015 Mapple Street",
    "city" : "San Francisco",
    "state" : "CA",
    "zip_code" : 94105
  }
}
</code></pre>

<p>Another thing you do with array, is to represent &ldquo;one-to-many&rdquo; relations. These relations in your RDBMS are based on multiple tables and foreign keys.
In document databases, like MongoDB, these relations are, most of the time, represented using an <em>array of documents</em>, something like (look at the <code>items</code> field):</p>

<pre><code class="json">{
  "_id" : 45218468309,
  "date" : ISODate("2015-01-28T09:40:50.615Z"),
  "customer" : {
    "id" : 654321,
    "name" : "John Doe"
  },
  "ship_to" : {
    "name" : "John Doe",
    "company" : "Resultri",
    "street" : "1015 Mapple Street",
    "city" : "San Francisco",
    "state" : "CA",
    "zip_code" : 94105
  },
  "items" : [
    {
      "sku" : "WA34R",
      "description" : "Wireless Qwerty Keyboard",
      "quantity" : 1,
      "unit_price" : 41.5,
      "price" : 41.5,
      "vat" : 20
    },
    {
      "sku" : "MW003",
      "description" : "MiWatch",
      "quantity" : 2,
      "unit_price" : 245,
      "price" : 490,
      "vat" : 20
    }
  ]
}
</code></pre>

<p>Documents above are not necessary complete, I just want to focus on the various operations you can do on these arrays.</p>

<p><em>Note: you can add these documents into your MongoDB instance, I will use the collections <code>customers</code> and <code>orders</code>.</em></p>

<h3>Adding new interest to the user</h3>

<p>To achieve this you have 2 operators that you can use in your update: <a href="1"><code>$push</code></a> and <a href="2"><code>$addToSet</code></a>. Since these one a very simple I won&rsquo;t go into too much details.</p>

<p>The <code>$push</code> will add the value at the end of the list, if the value already exits it will be added (many copies), this is why it makes sense to use the <code>$addToSet</code> operator, that only add the value if the value does not already exist in the array.</p>

<pre><code>db.customers.update(
  { "_id" : 654321  },
  { "$addToSet" : { "interested_by" :  "sports"}  }
);
</code></pre>

<p>This update command above <strong>will not change</strong> the document since the &ldquo;sports&rdquo; value is already in the list.</p>

<pre><code>db.customers.update(
  { "_id" : 654321  },
  { "$addToSet" : { "interested_by" :  "books"}  }
);
</code></pre>

<p>This <strong>will add</strong> the &ldquo;books&rdquo; value at the end of the list.</p>

<p>If the attribute <code>interested_by</code> does not exist in the document, it will be added with one single entry (here the <code>$push</code> is working the same way ).</p>

<p>If the attribute is not an array, the database will not do anything and return the error <a href="3">#16837</a> <em>&ldquo;The field &lsquo;first_name&rsquo; must be an array but is of type String in document&rdquo;</em>.</p>

<p>Here we use <em>interest</em>, but you can imagine doing the same thing for tagging, or any other business use case with a list of values.</p>

<h3>Adding a new item into an order</h3>

<p>The previous case, is very simple since it is a scalar value. Now I need to add a new order line, it is not harder than before:</p>

<pre><code>db.orders.update(
  { "_id" : 45218468309   },
  {
    "$push" : {
      "items" : {
        "sku" : "MO001",
        "description" : "Bluetooth mouse",
        "quantity" : 1,
        "unit_price" : 20.00,
        "price" : 20.00,
        "vat" : 20.00
      }
    }
  }
);
</code></pre>

<p>So you can see now that the value is added at the end of the list.</p>

<h3>Updating an item in the order</h3>

<p>Let&rsquo;s look at another requirement. Now I need to update for example the quantity of one of the line. In your relational application it is <em>easy</em> in the sense that you have one single record to update(in reality it is a different story since application are using complex data layer).</p>

<p>You can do the same, meaning you can only update the <em>items</em> directly in the array &ndash; (no need to replace the full document or list like I see too often).</p>

<p>For this, you  just need to use the <code>update</code> and <code>$set</code> and specify the positional operation <code>$</code>.</p>

<p>The <code>$</code> operator is a placeholder for the first entry in the array that match the filter (query document) sent to the update/findAndModify command.</p>

<p>In our example, to update a specific line in the order</p>

<p>The proper way is simply to use the an update and <code>$set</code>,
 but you have to select the exact entry in the array in your filter. For example in our case we want to update the number of mouses and the price, this will look like:</p>

<pre><code>db.orders.update(
  {
    "_id" : 45218468309,
    "items.sku" : "MO001"
  },
  {
    "$set" :
    {
        "items.$" : {
          "sku" : "MO001",
          "description" : "Bluetooth mouse",
          "quantity" : 2,
          "unit_price" : 20.00,
          "price" : 40.00,
          "vat" : 20.00
        }
    }
  }
);
</code></pre>

<p>As you can see, the <code>$</code> operator is telling MongoDB to update one specific entry in the array.</p>

<h2>Remove an item from the Array</h2>

<p>You have learned so far that you can easily query and add values into an array; using the same appraoch you can also remove entry in an array. This is done using 3 operators : <code>$pop</code>, <code>$pull</code> and <code>$pullAll</code></p>

<ul>
<li>The <code>$pop</code> operator removes one element from the end of the array</li>
<li>The <code>$pull</code> operator removes <em>all</em> elements in the array that match a specified value.</li>
<li>The <code>$pullAll</code> operator removes <em>all</em> elements in the array that match any of the specified values.</li>
</ul>


<h4>Remove some interests from a customer</h4>

<p>For example, let&rsquo;s remove the &ldquo;electronics&rdquo; interest from the customer id 654321.</p>

<pre><code>db.customers.update(
  { "_id" : 654321  },
  { "$pull" : { "interested_by" :  "electronics"}  }
);
</code></pre>

<p>If you want to remove sports and music interest from the customer you can use the <code>$pullAll</code> operator as follow:</p>

<pre><code>db.customers.update(
  { "_id" : 654321  },
  { "$pullAll" : { "interested_by" :  ["sports","music"]}  }
);
</code></pre>

<p>Here we use <em>interest</em>, but you can imagine doing the same thing for tagging, or any other business use case with a list of values.</p>

<h4>Remove item into an order</h4>

<p>Using the same operator you can also remove a line order (item) from an order document, for example let&rsquo;s remove the line with the item MO001 (Bluetooth mouse). For this we can use the <code>$pull</code> operator with the proper sku.</p>

<pre><code>db.orders.update(
  {
    "_id" : 45218468309,
  },
  {
    "$pull" : { "items" : { "sku" : "MO001" } }
  }
);
</code></pre>

<h3>Conclusion</h3>

<p>In this article you have learn how to create/edit arrays in JSON documents.</p>

<p>In addition to all the update operators, MongoDB provides many operators for querying arrays such as  <a href="5">$size</a> or <a href="4"><code>$elemMatch</code></a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to MongoDB Geospatial Feature]]></title>
    <link href="http://tgrall.github.io/blog/2014/08/21/introduction-to-mongodb-geospatial-feature/"/>
    <updated>2014-08-21T15:30:02+02:00</updated>
    <id>http://tgrall.github.io/blog/2014/08/21/introduction-to-mongodb-geospatial-feature</id>
    <content type="html"><![CDATA[<p>This post is a quick and simple introduction to Geospatial feature of MongoDB 2.6 using simple dataset and queries.</p>

<h3>Storing Geospatial Informations</h3>

<p>As you know you can store any type of data, but if you want to query them you need to use some coordinates, and create index on them. MongoDB supports three types of indexes for GeoSpatial queries:</p>

<ul>
<li><a href="http://docs.mongodb.org/manual/core/2d/">2d Index</a> : uses simple coordinate (longitude, latitude). As stated in the documentation: <em>The 2d index is intended for legacy coordinate pairs used in MongoDB 2.2 and earlier</em>. For this reason, I won&rsquo;t detail anything about this in this post. Just for the record 2d Index are used to query data stored as points on a two-dimensional plane</li>
<li><a href="http://docs.mongodb.org/manual/core/2dsphere/">2d Sphere Index</a> : support queries of any geometries on an-earth-like sphere, the data can be stored as GeoJSON and legacy coordinate pairs (longitude, latitude). For the rest of the article I will use this type of index and focusing on GeoJSON.</li>
<li><a href="http://docs.mongodb.org/manual/core/geohaystack/">Geo Haystack</a> : that are used to query on very small area. It is today less used by applications and I will not describe it in this post.
So this article will focus now on the 2d Sphere index with GeoJSON format to store and query documents.</li>
</ul>


<p><em>So what is GeoJSON?</em></p>

<p>You can look at the <a href="http://geojson.org/">http://geojson.org/</a> site, let&rsquo;s do a very short explanation. GeoJSON is a format for encoding, in JSON, a variety of geographic data structures, and support the following types:  Point , LineString , Polygon , MultiPoint , MultiLineString , MultiPolygon and Geometry.</p>

<p>The GeoJSON format  is quite straightforward based, for the simple geometries, on two attributes: type and coordinates. Let&rsquo;s take some examples:</p>

<p>The city where I spend all my childhood, Pleneuf Val-André, France, has the following coordinates (from Wikipedia)</p>

<p><code>48° 35′ 30.12″ N, 2° 32′ 48.84″ W</code></p>

<p>This notation is a point, based on a latitude &amp; longitude using the <a href="http://en.wikipedia.org/wiki/World_Geodetic_System">WGS 84</a> (Degrees, Minutes, Seconds) system. Not very easy to use by application/code, this is why it is also possible to represent the exact same point using the following values for latitude &amp; longitude:</p>

<p><code>48.5917, -2.5469</code></p>

<p>This one uses the <a href="http://en.wikipedia.org/wiki/World_Geodetic_System">WGS 84</a> (Decimal Degrees) system. This is the coordinates you see use in most of the application/API you are using as developer (eg: Google Maps/Earth for example)</p>

<p>By default GeoJSON, and MongoDB use these values but <strong>the coordinates must be stored in the longitude, latitude order</strong>, so this point in GeoJSON will look like:</p>

<pre><code class="json">{
  "type": "Point",
  "coordinates": [
  -2.5469,  
  48.5917
  ]
}
</code></pre>

<p><img class="<a" src="href="http://2.bp.blogspot.com/-0GfvAvSgLM8/U_NwAR_BCpI/AAAAAAAAArI/INweKtutfDQ/s1600/01-geojson-point.png">http://2.bp.blogspot.com/-0GfvAvSgLM8/U_NwAR_BCpI/AAAAAAAAArI/INweKtutfDQ/s1600/01-geojson-point.png</a>&#8221;></p>

<p>This is a simple &ldquo;Point&rdquo;, let&rsquo;s now for example look at a line, a very nice walk on the beach :</p>

<pre><code class="json">{
  "type": "LineString",
  "coordinates": [
    [-2.551082,48.5955632],
    [-2.551229,48.594312],
    [-2.551550,48.593312],
    [-2.552400,48.592312],
    [-2.553677, 48.590898]
  ]
  }
</code></pre>

<p><img class="<a" src="href="http://1.bp.blogspot.com/-dg_myaJAG-c/U_Nv80jrncI/AAAAAAAAArA/utmCcBlQeqY/s1600/02-geojson-linestring.png">http://1.bp.blogspot.com/-dg_myaJAG-c/U_Nv80jrncI/AAAAAAAAArA/utmCcBlQeqY/s1600/02-geojson-linestring.png</a>&#8221;></p>

<p>So using the same approach you will be able to create MultiPoint, MultiLineString, Polygon, MultiPolygon. It is also possible to mix all these in a single document using a GeometryCollection. The following example is a Geometry Collection of MultiLineString and Polygon over Central Park:</p>

<pre><code class="json">{
  "type" : "GeometryCollection",
  "geometries" : [
    {
      "type" : "Polygon",
      "coordinates" : [
[
  [ -73.9580, 40.8003 ],
  [ -73.9498, 40.7968 ],
  [ -73.9737, 40.7648 ],
  [ -73.9814, 40.7681 ],
  [ -73.9580, 40.8003  ]
]
      ]
    },
    {
      "type" : "MultiLineString",
      "coordinates" : [
[ [ -73.96943, 40.78519 ], [ -73.96082, 40.78095 ] ],
[ [ -73.96415, 40.79229 ], [ -73.95544, 40.78854 ] ],
[ [ -73.97162, 40.78205 ], [ -73.96374, 40.77715 ] ],
[ [ -73.97880, 40.77247 ], [ -73.97036, 40.76811 ] ]
      ]
    }
  ]
}
</code></pre>

<p><img class="<a" src="href="http://3.bp.blogspot.com/-tIxoUIeSMWw/U_SUsEJ_EDI/AAAAAAAAArY/2qelBrB1xRY/s1600/03-gejson-collection.png">http://3.bp.blogspot.com/-tIxoUIeSMWw/U_SUsEJ_EDI/AAAAAAAAArY/2qelBrB1xRY/s1600/03-gejson-collection.png</a>&#8221;></p>

<p>Note: You can if you want test/visualize these JSON documents using the <a href="http://geojsonlint.com/">http://geojsonlint.com/</a> service.</p>

<h5>Now what? Let&rsquo;s store data!</h5>

<p>Once you have a GeoJSON document you just need to store it into your document. For example if you want to store a document about JFK Airport with its location you can run the following command:</p>

<pre><code class="js">db.airports.insert(
{
  "name" : "John F Kennedy Intl",
  "type" : "International",
  "code" : "JFK",
  "loc" : {
    "type" : "Point",
    "coordinates" : [ -73.778889, 40.639722 ]
  }
}
</code></pre>

<p>Yes this is that simple! You just save the GeoJSON as one of the attribute of the document, <code>loc</code> in this example)</p>

<h3>Querying Geospatial Informations</h3>

<p>Now that we have the data stored in MongoDB, it is now possible to use the geospatial information to do some interesting queries.</p>

<p>For this we need a sample dataset. I have created one using some open data found in various places. This dataset contains the following informations:</p>

<ul>
<li>airports collection with the list of US airport (Point)</li>
<li>states collection with the list of US states (MultiPolygon)</li>
</ul>


<p>I have created this dataset from various OpenData sources ( <a href="http://geocommons.com/">http://geocommons.com/</a> , <a href="http://catalog.data.gov/dataset">http://catalog.data.gov/dataset</a> ) and use <a href="https://github.com/mapbox/togeojson">toGeoJSON</a> to convert them into the proper format.</p>

<p>Let&rsquo;s install the dataset:</p>

<ol>
<li>Download it from <a href="https://www.dropbox.com/s/yui7shcud2xbxt7/geo.zip">here</a></li>
<li>Unzip geo.zip file</li>
<li>Restore the data into your mongoDB instance, using the following command</li>
</ol>


<pre><code>mongorestore geo.zip
</code></pre>

<p>MongoDB allows applications to do the following types of query on geospatial data:</p>

<ul>
<li>inclusion</li>
<li>intersection</li>
<li>proximity</li>
</ul>


<p>Obviously, you will be able to use all the other operator in addition to the geospatial ones. Let&rsquo;s now look at some concrete examples.</p>

<h4>Inclusion</h4>

<p>Find all the airports in California. For this you need to get the California location (Polygon) and use the command $geoWithin in the query. From the shell it will look like :</p>

<pre><code class="js">use geo
var cal = db.states.findOne(  {code : "CA"}  );

db.airports.find(
{
  loc : { $geoWithin : { $geometry : cal.loc } }
},
{ name : 1 , type : 1, code : 1, _id: 0 }
);
</code></pre>

<p>Result:</p>

<pre><code class="json">{ "name" : "Modesto City - County", "type" : "", "code" : "MOD" }
...
{ "name" : "San Francisco Intl", "type" : "International", "code" : "SFO" }
{ "name" : "San Jose International", "type" : "International", "code" : "SJC" }
...
</code></pre>

<p>So the query is using the &ldquo;California MultiPolygon&rdquo; and looks in the airports collection to find all the airports that are in these polygons. This looks like the following image on a map:</p>

<p><img class="<a" src="href="http://1.bp.blogspot.com/-AO6C6fgsrYQ/U_Wyr2RHPWI/AAAAAAAAAro/hVn6YFJQtNI/s1600/04-geojson-cal-airport.png">http://1.bp.blogspot.com/-AO6C6fgsrYQ/U_Wyr2RHPWI/AAAAAAAAAro/hVn6YFJQtNI/s1600/04-geojson-cal-airport.png</a>&#8221;></p>

<p>You can use any other query features or criteria, for example you can limit the query to international airport only sorted by name :</p>

<pre><code class="js">db.airports.find(
{
  loc : { $geoWithin : { $geometry : cal.loc } },
  type : "International"
},
{ name : 1 , type : 1, code : 1, _id: 0 }
).sort({ name : 1 });
</code></pre>

<p>Result:</p>

<pre><code class="json">{ "name" : "Los Angeles Intl", "type" : "International", "code" : "LAX" }
{ "name" : "Metropolitan Oakland Intl", "type" : "International", "code" : "OAK" }
{ "name" : "Ontario Intl", "type" : "International", "code" : "ONT" }
{ "name" : "San Diego Intl", "type" : "International", "code" : "SAN" }
{ "name" : "San Francisco Intl", "type" : "International", "code" : "SFO" }
{ "name" : "San Jose International", "type" : "International", "code" : "SJC" }
{ "name" : "Southern California International", "type" : "International", "code" : "VCV" }
</code></pre>

<p>I do not know if you have looked in detail, but we are querying these documents with no index. You can run a query with the <code>explain()</code> to see what&rsquo;s going on. The <code>$geoWithin</code> operator does not need index but your queries will be more efficient with one so let&rsquo;s create the index:</p>

<pre><code class="js">db.airports.ensureIndex( { "loc" : "2dsphere" } );
</code></pre>

<p>Run the explain and you will se the difference.</p>

<h4>Intersection</h4>

<p>Suppose you want to know what are all the adjacent states to California, for this we just need to search for all the states that have coordinates that &ldquo;intersects&rdquo; with California. This is done with the following query:</p>

<pre><code class="js">var cal = db.states.findOne(  {code : "CA"}  );
db.states.find(
{
  loc : { $geoIntersects : { $geometry : cal.loc  }  } ,
  code : { $ne : "CA"  }  
},
{ name : 1, code : 1 , _id : 0 }
);
</code></pre>

<p>Result:</p>

<pre><code class="json">{ "name" : "Oregon", "code" : "OR" }
{ "name" : "Nevada", "code" : "NV" }
{ "name" : "Arizona", "code" : "AZ" }
</code></pre>

<p><img class="<a" src="href="http://3.bp.blogspot.com/--Kh1AzmsaSU/U_XreY-tRlI/AAAAAAAAAr4/cS1pgjgF2Pc/s1600/05-geojson-intersect.png">http://3.bp.blogspot.com/&#8211;Kh1AzmsaSU/U_XreY-tRlI/AAAAAAAAAr4/cS1pgjgF2Pc/s1600/05-geojson-intersect.png</a>&#8221;></p>

<p>Same as before <code>$geoIntersect</code> operator does not need an index to work, but it will be more efficient with the following index:</p>

<pre><code class="js">db.states.ensureIndex( { loc : "2dsphere" } );
</code></pre>

<h4>Proximity</h4>

<p>The last feature that I want to highlight in this post is related to query with proximity criteria. Let&rsquo;s find all the international airports that are located at less than 20km from the reservoir in NYC Central Park. For this you will be using the <code>$near</code> operator.</p>

<pre><code class="js">db.airports.find(
{
  loc : {
    $near : {
      $geometry : {
        type : "Point" ,
        coordinates : [-73.965355,40.782865]  
      },
      $maxDistance : 20000
    }
  },
  type : "International"
},
{
  name : 1,
  code : 1,
  _id : 0
}
);
</code></pre>

<p>Results:</p>

<pre><code class="json">{ "name" : "La Guardia", "code" : "LGA" }
{ "name" : "Newark Intl", "code" : "EWR"}
</code></pre>

<p>So this query returns 2 airports, the closest being La Guardia, since the <code>$near</code> operator sorts the results by distance. Also it is important to raise here that the <code>$near</code> operator requires an index.</p>

<h3>Conclusion</h3>

<p>In this first post about geospatial feature you have learned:</p>

<ul>
<li>the basic of GeoJSON</li>
<li>how to query documents with inclusion, intersection and proximity criteria.</li>
</ul>


<p>You can now play more with this for example integrate this into an application that expose data into some UI, or see how you can use the geospatial operators into a aggregation pipeline.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pagination With Couchbase]]></title>
    <link href="http://tgrall.github.io/blog/2013/10/01/pagination-with-couchbase/"/>
    <updated>2013-10-01T02:00:00+02:00</updated>
    <id>http://tgrall.github.io/blog/2013/10/01/pagination-with-couchbase</id>
    <content type="html"><![CDATA[<p>If you have to deal with a large number of documents when doing queries against a Couchbase cluster it is important to use pagination to get rows by page. You can find some information in the documentation in the chapter &ldquo;<a href="http://docs.couchbase.com/couchbase-manual-2.2/#pagination">Pagination</a>&rdquo;, but I want to go in more details and sample code in this article.</p>

<p>For this example I will start by creating a simple view based on the <code>beer-sample</code> dataset, the view is used to find brewery by country:</p>

<pre><code class="js">function (doc, meta) {
  if (doc.type == "brewery" &amp;amp;&amp;amp; doc.country){
    emit(doc.country);
  }
}
</code></pre>

<p>This view list all the breweries by country, the index looks like:</p>

<table>
<tbody>
<tr><th>Doc id</th><th>Key</th><th>Value</th></tr>
<tr><td>bersaglier</td><td>Argentina</td><td>null</td></tr>
<tr><td>cervecera_jerome</td><td>Argentina</td><td>null</td></tr>
<tr><td>brouwerij_nacional_balashi</td><td>Aruba</td><td>null</td></tr>
<tr><td>australian_brewing_corporation</td><td>Australia</td><td>null</td></tr>
<tr><td>carlton_and_united_breweries</td><td>Australia</td><td>null</td></tr>
<tr><td>coopers_brewery</td><td>Australia</td><td>null</td></tr>
<tr><td>foster_s_australia_ltd</td><td>Australia</td><td>null</td></tr>
<tr><td>gold_coast_brewery</td><td>Australia</td><td>null</td></tr>
<tr><td>lion_nathan_australia_hunter_street</td><td>Australia</td><td>null</td></tr>
<tr><td>little_creatures_brewery</td><td>Australia</td><td>null</td></tr>
<tr><td>malt_shovel_brewery</td><td>Australia</td><td>null</td></tr>
<tr><td>matilda_bay_brewing</td><td>Australia</td><td>null</td></tr>
<tr><td>&#8230;</td><td>&#8230;</td><td>&#8230;</td></tr>
<tr><td>&#8230;</td><td>&#8230;</td><td>&#8230;</td></tr>
<tr><td>&#8230;</td><td>&#8230;</td><td>&#8230;</td></tr>
<tr><td>yellowstone_valley_brewing</td><td>United States</td><td>null</td></tr>
<tr><td>yuengling_son_brewing</td><td>United States</td><td>null</td></tr>
<tr><td>zea_rotisserie_and_brewery</td><td>United States</td><td>null</td></tr>
<tr><td>fosters_tien_gang</td><td>Viet Nam</td><td>null</td></tr>
<tr><td>hue_brewery</td><td>Viet Nam</td><td>null</td></tr>
</tbody></table>


<p>So now you want to navigate in this index with a page size of 5 rows.</p>

<!--more-->


<h3>Using skip / limit Parameters</h3>

<p>The most simplistic approach is to use <span style="font-family: Courier New, Courier, monospace;">limit</span> and <span style="font-family: Courier New, Courier, monospace;">skip</span> parameters for example:</p>

<p>Page 1 : <code>?limit=5&amp;amp;skip0</code><br/>
Page 2 : <code>?limit=5&amp;amp;skip=5</code>
&hellip;
Page x : <code>?limit=5&amp;amp;skip(limit*(page-1))</code></p>

<p>You can obviously use any other parameters you need to do range or key queries (<code>startkey/endkey, key, keys</code>) and sort option (<code>descending</code>).</p>

<p>This is simple but not the most efficient way, since the query engine has to read all the rows that match the query, until the skip value is reached.</p>

<p>Some code sample in python that paginate using this view :</p>

<p><div><script src='https://gist.github.com/6174762.js'></script>
<noscript><pre><code>from couchbase import Couchbase
cb = Couchbase.connect(bucket=&#39;beer-sample&#39;)

hasRow = True
rowPerPage = 5
page = 0
currentStartkey=&quot;&quot;
startDocId=&quot;&quot;

while hasRow :
  hasRow = False
	skip = 0 if page == 0 else 1
	page = page + 1
	print &quot;-- Page %s --&quot; % (page)
	rows = cb.query(&quot;test&quot;, &quot;by_country&quot;, limit=rowPerPage, skip=skip, startkey=currentStartkey, startkey_docid=startDocId)
	for row in rows:
		hasRow = True
		print &quot;Country: \&quot;%s\&quot; \t Id: &#39;%s&#39;&quot; % (row.key, row.docid)
		currentStartkey = row.key
		startDocId = row.docid
	print &quot; -- -- -- -- \n&quot;



</code></pre></noscript></div>
</p>

<p>This application loops on all the pages until the end of the index.</p>

<p>As I said before this is not the best approach since the system must read all the values until the skip is reached. The following example shows a better way to deal with this.</p>

<h3>Using startkey / startkey_docid parameters</h3>

<p>To make this pagination more efficient it is possible to take another approach. This approach uses the  <code>startkey</code> and <code>startkey_docid</code>  to select the proper documents.</p>

<ul>
<li><code>The startkey</code> parameter will be the value of the key where the query should start to read (based on the last key of the &ldquo;previous page&rdquo;</li>
<li>Since for a key for example &ldquo;Germany&rdquo; you may have one or more ids (documents) it is necessary to say to Couchbase query engine where to start, for this you need to use the <code>startkey_docid</code> parameter, and ignore this id since it is the last one of the previous page.</li>
</ul>


<p>So if we look at the index, and add a row number to explain the pagination</p>

<table>
<tbody>
<tr><th>Row num</th><th>Doc id</th><th>Key</th><th>Value</th></tr>
<tr><td colspan="4"><br />
Query for page 1<br />
<span style="font-family: Courier New, Courier, monospace;">?limit=5</span></td></tr>
<tr><td>1</td><td></td><td>bersaglier</td><td>Argentina</td><td>null</td></tr>
<tr><td>2</td><td></td><td>cervecera_jerome</td><td>Argentina</td><td>null</td></tr>
<tr><td>3</td><td></td><td>brouwerij_nacional_balashi</td><td>Aruba</td><td>null</td></tr>
<tr><td>4</td><td></td><td>australian_brewing_corporation</td><td>Australia</td><td>null</td></tr>
<tr><td>5</td><td></td><td>carlton_and_united_breweries</td><td>Australia</td><td>null</td></tr>
<tr><td colspan="4">
Query for page 2<br />
<span style="font-family: Courier New, Courier, monospace;">?limit=5&amp;startkey=&#8221;Australia&#8221;&amp;startkey_docid=carlton_and_united_breweries&amp;skip=1
</td></tr>
<tr><td>6</td><td></td><td>coopers_brewery</td><td>Australia</td><td>null</td></tr>
<tr><td>7</td><td></td><td>foster_s_australia_ltd</td><td>Australia</td><td>null</td></tr>
<tr><td>8</td><td></td><td>gold_coast_brewery</td><td>Australia</td><td>null</td></tr>
<tr><td>9</td><td></td><td>lion_nathan_australia_hunter_street</td><td>Australia</td><td>null</td></tr>
<tr><td>10</td><td></td><td>little_creatures_brewery</td><td>Australia</td><td>null</td></tr>
<tr><td colspan="4"><br />
Query for page 3<br />
<span style="font-family: Courier New, Courier, monospace;">?limit=5&amp;startkey=&#8221;Australia&#8221;&amp;startkey_docid=little_creatures_brewery</span><span style="font-family: 'Courier New', Courier, monospace;">&amp;skip=1</span>
</td></tr>
<tr><td>11</td><td></td><td>malt_shovel_brewery</td><td>Australia</td><td>null</td></tr>
<tr><td>12</td><td></td><td>matilda_bay_brewing</td><td>Australia</td><td>null</td></tr>
<tr><td>&#8230;</td><td>&#8230;</td><td>&#8230;</td></tr>
<tr><td>&#8230;</td><td>&#8230;</td><td>&#8230;</td></tr>
<tr><td>&#8230;</td><td>&#8230;</td><td>&#8230;</td></tr>
<tr><td>&#8230;</td><td></td><td>yellowstone_valley_brewing</td><td>United States</td><td>null</td></tr>
<tr><td>&#8230;</td><td></td><td>yuengling_son_brewing</td><td>United States</td><td>null</td></tr>
<tr><td>&#8230;</td><td></td><td>zea_rotisserie_and_brewery</td><td>United States</td><td>null</td></tr>
<tr><td>&#8230;</td><td></td><td>fosters_tien_gang</td><td>Viet Nam</td><td>null</td></tr>
<tr><td>&#8230;</td><td></td><td>hue_brewery</td><td>Viet Nam</td><td>null</td></tr>
</tbody></table>


<p>So as you can see in the examples above, the query uses the startkey, a document id, and just passes it using skip=1.</p>

<p>Let&rsquo;s now look at the application code, once again in Python</p>

<p><div><script src='https://gist.github.com/6176322.js'></script>
<noscript><pre><code>
from couchbase import Couchbase
cb = Couchbase.connect(bucket=&#39;beer-sample&#39;)

hasRow = True
rowPerPage = 5
page = 0
currentStartkey=&quot;&quot;
startDocId=&quot;&quot;

while hasRow :
	hasRow = False
	skip = 0 if page == 0 else 1
	page = page + 1
	print &quot;-- Page %s --&quot; % (page)
	rows = cb.query(&quot;test&quot;, &quot;by_country&quot;, limit=rowPerPage, skip=skip, startkey=currentStartkey, startkey_docid=startDocId)
	for row in rows:
		hasRow = True
		print &quot;Country: \&quot;%s\&quot; \t Id: &#39;%s&#39;&quot; % (row.key, row.docid)
		currentStartkey = row.key
		startDocId = row.docid
	print &quot; -- -- -- -- \n&quot;

</code></pre></noscript></div>
</p>

<p>This application loops on all the pages until the end of the index</p>

<p>Using this approach, the application start to read the index at a specific key (<code>startkey</code> parameter), and only loop on the necessary entry in the index. This is more efficient than using the simple skip approach.</p>

<h4>Views with Reduce function</h4>

<p>When your view is using a reduce function, if you want to paginate on the various keys only (with the reduce function) you need to use the <code>skip</code> and <code>limit</code> parameters.</p>

<p>When you are using the  paramater <code>startkey_docid</code> with a reduce function it will calculate the reduce only to the subset of document ids that are part of your query.</p>

<h3>Couchbase Java SDK Paginator</h3>

<p>In the previous examples, I have showed how to do pagination using the various query parameters. The Java SDK provides a Paginator object to help developers to deal with pagination. The following example is using the same view with the Paginator API.</p>

<p><div><script src='https://gist.github.com/6774932.js'></script>
<noscript><pre><code>package com.couchbase.devday;

import com.couchbase.client.CouchbaseClient;
import com.couchbase.client.protocol.views.*;
import java.net.URI;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.TimeUnit;
import java.util.logging.ConsoleHandler;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.Logger;

public class JavaPaginatorSample {

public static void main(String[] args) {

	configure();
	System.out.println(&quot;--------------------------------------------------------------------------&quot;);
	System.out.println(&quot;\tCouchbase - Paginator&quot;);
	System.out.println(&quot;--------------------------------------------------------------------------&quot;);

    List&lt;URI&gt; uris = new LinkedList&lt;URI&gt;();
    uris.add(URI.create(&quot;http://127.0.0.1:8091/pools&quot;));

    CouchbaseClient cb = null;
    try {
    	cb = new CouchbaseClient(uris, &quot;beer-sample&quot;, &quot;&quot;);
	  	System.out.println(&quot;--------------------------------------------------------------------------&quot;);
	  	System.out.println(&quot;Breweries (by_name) with docs &amp; JSON parsing&quot;);
		View view = cb.getView(&quot;test&quot;, &quot;by_country&quot;);
		Query query = new Query();
		int docsPerPage = 5;

		Paginator paginatedQuery = cb.paginatedQuery(view, query, docsPerPage);
		int pageCount = 0;
		while(paginatedQuery.hasNext()) {
			pageCount++;
			System.out.println(&quot; -- Page &quot;+ pageCount +&quot; -- &quot;);
			ViewResponse response = paginatedQuery.next();
			for (ViewRow row : response) {
				System.out.println(row.getKey() + &quot; : &quot; + row.getId());
			}
			System.out.println(&quot; -- -- -- &quot;);
		}
		
		System.out.println(&quot;\n\n&quot;);
    	cb.shutdown(10, TimeUnit.SECONDS);
    } catch (Exception e) {
    	System.err.println(&quot;Error connecting to Couchbase: &quot; + e.getMessage());
    }
}



private static void configure() {

	for(Handler h : Logger.getLogger(&quot;com.couchbase.client&quot;).getParent().getHandlers()) {
		if(h instanceof ConsoleHandler) {
			h.setLevel(Level.OFF);
		}
	}
	Properties systemProperties = System.getProperties();
	systemProperties.put(&quot;net.spy.log.LoggerImpl&quot;, &quot;net.spy.memcached.compat.log.SunLogger&quot;);
	System.setProperties(systemProperties);

	Logger logger = Logger.getLogger(&quot;com.couchbase.client&quot;);
	logger.setLevel(Level.OFF);
	for(Handler h : logger.getParent().getHandlers()) {
		if(h instanceof ConsoleHandler){
			h.setLevel(Level.OFF);
		}
	}
}

}
</code></pre></noscript></div>
</p>

<p>So as you can see you can easily paginate on the results of a Query using the Java Paginator.</p>

<ul>
<li>At the line #37, the Paginator is created from using the view and query objects and a page size is specified</li>
<li>Then you just need to use the hasNext() and next() methods to navigate in the results.</li>
</ul>


<p>The Java Paginator  is aware of the fact that they query is using a reduce or not, so you can use it with all type of queries - Internally it will switch between the skip/limit approach and the doc_id approaches. You can <a href="https://github.com/couchbase/couchbase-java-client/blob/1.1.9/src/main/java/com/couchbase/client/protocol/views/Paginator.java#L176-L195">see how it is done in the Paginator class</a>.</p>

<p>Note that if you want to do that in a Web application between HTTP request you must keep the Paginator object in the user session since the current API keeps the current page in its state.</p>

<h3>Conclusion</h3>

<p>In this blog post you have  learned how to deal with pagination in Couchbase views; to summarize</p>

<ul>
<li>The pagination is based on some specific parameters that you send when executing a query.</li>
<li>Java developers can use the <a href="http://www.couchbase.com/autodocs/couchbase-java-client-1.2.0/com/couchbase/client/protocol/views/Paginator.html">Paginator</a> class that simplifies pagination.</li>
</ul>


<p>I am inviting you to look at the new Couchbase Query Language N1QL, still under development, that will provide more options to developers including pagination, using LIMIT &amp; OFFSET parameters, for example:</p>

<pre><code class="sql">SELECT fname, age
FROM tutorial
WHERE age &gt; 30
LIMIT 2
OFFSET 2
</code></pre>

<p>If you want to learn more about N1QL:</p>

<ul>
<li><a href="http://query.couchbase.com/">N1QL on Couchbase Community Portal</a></li>
<li><a href="http://query.pub.couchbase.com/tutorial/">N1QL Online Tutorial</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Implement Document Versioning With Couchbase]]></title>
    <link href="http://tgrall.github.io/blog/2013/07/18/how-to-implement-document-versioning-with-couchbase/"/>
    <updated>2013-07-18T08:59:50+02:00</updated>
    <id>http://tgrall.github.io/blog/2013/07/18/how-to-implement-document-versioning-with-couchbase</id>
    <content type="html"><![CDATA[<h3>Introduction</h3>

<p>Developers are often asking me how to &ldquo;version&rdquo; documents with Couchbase 2.0. The short answer is: the clients and server do not expose such feature, but it is quite easy to implement.</p>

<p>In this article I will use a basic approach, and you will be able to extend it depending of your business requirements.</p>

<!-- more -->


<h3>Design</h3>

<p>The first thing to do is to select how to &ldquo;store/organize&rdquo; the versions of your document, and for this you have different designs:</p>

<ul>
<li>copy the versions the document into new documents</li>
<li>copy the versions of the document into a list of embedded documents</li>
<li>store the list of attributes that have been changed into a embedded element (or new documents)</li>
<li>store the &ldquo;delta&rdquo;</li>
<li>…</li>
</ul>


<p>You will have to chose the design based on your application requirements (business logic, size of the dataset, &hellip;).  For this article, let&rsquo;s use one of the most simplistic approach: create new document for each version with the following rules for the keys:</p>

<ol>
<li>The current version is is a simple Key/Document, no change to the key.</li>
<li>The version is a copy of the document, and the version number is added to the key.</li>
</ol>


<p>This looks like:</p>

<pre><code>Current Version   mykey
Version 1         mykey::v1
Version 2         mykey::v2
...               ...
</code></pre>

<p>With this approach, existing applications will always use the current version of the document, since the key is not changed. But this approach creates new documents that will be indexed by existing views.</p>

<p>For example, in the Beer Sample application, the following view is used to list the beer by name:</p>

<pre><code class="js">function (doc, meta) {
  if(doc.type &amp;amp;&amp;amp; doc.type == "beer") {
    emit(doc.name);
  }
}
</code></pre>

<p>It is quite simple to &ldquo;support&rdquo; versioning without impacting the existing code, except the view itself. The new view needs to emit keys,value only for the current version of the document. This is the new view code:</p>

<pre><code>function (doc, meta) {
  if(doc.type &amp;amp;&amp;amp; doc.type == "beer" &amp;amp;&amp;amp; (meta.id).indexOf("::v") == -1   ) {
    emit(doc.name);
  }
}
</code></pre>

<p>With this change the existing applications that are using this view will continue to work with the same behavior.</p>

<h3>Implementing the versioning</h3>

<p>Based on this design, when the application needs to version the document, the following logic should happen:</p>

<ol>
<li>Get the current version of the document</li>
<li>Increment the version number (for example using another key that maintains the version number for each document)</li>
<li>Create the version with the new key  &ldquo;mykey::v1&rdquo;</li>
<li>Save the document current version</li>
</ol>


<p>Let&rsquo;s look at the code in Java</p>

<pre><code class="java">Object obj = client.get(key);
if (obj != null) {
  // get the next version, create or use the key: mykey_version
  long version = client.incr(key + "_version", 1, 1);
  String keyForVersion = key + "::v" + version; // mykey::v1
  try {
    client.set(keyForVersion, obj).get();
    } catch (Exception e) {
      logger.severe("Cannot save version "+ version + " for key "+ key +" - Error:"+ e.getMessage() );
    }
  }
  client.set(key, value);
</code></pre>

<p>Quite simple isn&rsquo;t?</p>

<p>The application can access the document using the key, but also get one version or the list of all versions, this is one of the reasons why it is interesting to create a key (<span style="font-family: Courier New, Courier, monospace;">mykey_version</span>), and use it also to delete documents and related versions.</p>

<p>Based on the previous comment, the delete operation looks like:</p>

<pre><code class="java">Object obj = client.get(key);
// need to delete all the version first
Object vObject = this.get(key + "_version");
if (vObject != null) {
  long biggerVersion = Long.parseLong((String) vObject);
  try {
    // delete all the versions
    for (int i = 1; i &lt;= biggerVersion; i++) {
      String versionKey = key + "::v" + i;
      client.delete(versionKey).get();
    }
    // delete the counter
    client.delete(key + "_version").get();
  } catch (InterruptedException e) {
    e.printStackTrace();
  } catch (ExecutionException e) {
    e.printStackTrace();
  }
}
client.delete(key);
</code></pre>

<h4>Use versioning</h4>

<p>As an example, I have created a small library available on GitHub <a href="https://github.com/tgrall/couchbase-how-to-versioning">https://github.com/tgrall/couchbase-how-to-versioning</a>, this library extends the Couchbase Client and overrides some of the operations : set, replace and delete. (the basic one: no TLL, no durability) As I said before this is just an example.</p>

<p><em>Build and Install</em></p>

<pre><code>git clone https://github.com/tgrall/couchbase-how-to-versioning.git
cd how-to-versioning
mvn clean install
</code></pre>

<p>Then add this library to your project in addition to Couchbase Java Client, for example in your pom.xml</p>

<pre><code class="xml">...
&lt;dependency&gt;
  &lt;groupid&gt;com.couchbase.howtos&lt;/groupid&gt;
  &lt;artifactid&gt;couchbase-how-to-versioning&lt;/artifactid&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupid&gt;couchbase&lt;/groupid&gt;
  &lt;artifactid&gt;couchbase-client&lt;/artifactid&gt;
  &lt;version&gt;1.1.8&lt;/version&gt;
&lt;/dependency&gt;

...
</code></pre>

<p><em>Code your application</em></p>

<p>Create a document and version it:</p>

<pre><code class="java">List&lt;uri&gt; uris = new LinkedList&lt;uri&gt;();
uris.add(URI.create("http://127.0.0.1:8091/pools"));
CouchbaseClientWithVersioning client = null
try {
  client = new CouchbaseClientWithVersioning(uris, "default", "");
  String key = "key-001";
  client.set(key, "This is the original version");
  System.out.printf("Original '%s' .\n", client.get(key));
  client.set(key, "This is a new version", true); // create a new version
  System.out.printf("Current Version '%s' .\n", client.get(key));
  System.out.printf("Version 1 '%s' .\n", client.get(key, 1));
  client.set(key, "This is another version", true); // create a new version
  System.out.printf("All versions %s .\n", client.getAllVersions(key));
  client.deleteVersion(key, 1); // create a new version
  System.out.printf("All versions %s (after delete 1 version).\n", client.getAllVersions(key));
  client.delete(key); // create a new version
  System.out.printf("All versions %s (after delete the main key).\n", client.getAllVersions(key));
} catch (Exception e) {
  e.printStackTrace();
}
if (client !=null) {
  client.shutdown();
}
</code></pre>

<p>Quick explanation:</p>

<ul>
<li>Line 5: instead of using the <code>CouchbaseClient</code>, the application uses the extended <code>CouchbaseClientWithVersioning</code> class.</li>
<li>Line 7: create a new entry</li>
<li>Line 9: create a new version, the boolean value to &ldquo;true&rdquo; force the versioning of the document</li>
<li>The application use other methods such as get a specific version (line 11), get all versions (line 13), delete a specific version (line 14), and finally delete the key and all versions (line 16).</li>
</ul>


<p>So using this approach the developer controls explicitly when to create a version, since he has to add the boolean parameter in the set operation. In this small sample library it is also possible to do auto versioning, in this case all set and replace calls will create a version, to achieve that the developer just needs to call the setAutoVersioning(true) method. Something like:</p>

<pre><code class="java">client = new CouchbaseClientWithVersioning(uris, "default", "");
client.setAutomaticVersionning(true);
</code></pre>

<p>With this approach you can provide versioning to your application with minimal code change. You can test it in the Beer Sample application, just do not forget to change the views as documenter above to only return <em>current</em> version of the documents.</p>

<h3>Conclusion</h3>

<p>As you can see doing versioning in Couchbase is not that complicated, but it is something that must be done by your application based on its requirements and constraints. You have many different solution and none of these options is perfect for all use cases.</p>

<p>In this specific sample code, I am working with a simple design where I create a copy of the documents for each version. With this approach also, it is interesting to mention that you can version &ldquo;anything&rdquo;, not only JSON document but also any values.  As I said before, this is one possible approach, and like any design, it has some impact on the application or database, in this case most the database:</p>

<ul>
<li>Increase the number of keys and documents</li>
<li>Double - or more- the number of operations, for example when updating a document, the application needs to get the current value, create a version, save the current version.</li>
<li>Consistency management when adding new version and incrementing the version number (need to deal with errors when creating a new version, deleting the versions and counter&hellip;.)</li>
</ul>


<p>Many features could be added to this easily, for example:</p>

<ul>
<li>Limit to a specific number of version,</li>
<li>Enable the versioning only of replace() operation</li>
<li>Add specific attribute about versions in JSON document (for example date of the version)</li>
<li>&hellip;.</li>
</ul>


<p>If you are using versioning in your Couchbase application feel free to comment or write a small article that describes the way your are doing it.</p>
]]></content>
  </entry>
  
</feed>
